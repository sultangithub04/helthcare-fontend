# Task 12: Push Notifications with Web Push API

## üìã Task Overview

**Difficulty**: üü° **INTERMEDIATE**  
**Estimated Time**: 1 week  
**Priority**: MEDIUM  
**Category**: Real-time Features

### Objective

Implement browser push notifications using the Web Push API and service workers to send real-time alerts to users about appointment reminders, new messages, prescription updates, and other important events. Enable users to receive notifications even when the application is not open, improving engagement and user experience.

### Learning Outcomes

- Master Web Push API and service workers
- Implement push notification subscriptions
- Send notifications from backend using web-push
- Handle notification clicks and actions
- Manage notification permissions
- Store push subscriptions in database
- Test notifications across browsers
- Implement notification preferences

---

## üéØ Requirements

### Functional Requirements

1. **Notification Types**
   | Type | Priority | Example | Action |
   |------|----------|---------|--------|
   | Appointment Reminder | HIGH | "Appointment in 1 hour" | Open appointment |
   | New Message | HIGH | "Dr. Smith sent a message" | Open chat |
   | Prescription Ready | MEDIUM | "Prescription uploaded" | View prescription |
   | Payment Reminder | HIGH | "Payment pending" | Complete payment |
   | Appointment Confirmed | MEDIUM | "Appointment confirmed" | View details |

2. **User Preferences**

   - Enable/disable notifications per type
   - Set quiet hours (no notifications)
   - Choose notification sound
   - Desktop vs mobile preferences
   - Frequency controls

3. **Notification Features**
   - Rich notifications with images
   - Action buttons (Accept, Decline, View)
   - Badge icons
   - Notification grouping
   - Silent notifications
   - Persistent vs transient

### Technical Requirements

1. **Technology Stack**

   - **Frontend**: Service Worker API, Push API, Notification API
   - **Backend**: web-push (Node.js library)
   - **Database**: Store push subscriptions
   - **Free Service**: Self-hosted push server

2. **Browser Support**

   - Chrome/Edge (full support)
   - Firefox (full support)
   - Safari (limited support)
   - Mobile browsers

3. **Performance**
   - Notification delivery <5 seconds
   - Service worker < 100KB
   - Minimal battery impact
   - Offline notification queue

---

## üèóÔ∏è Push Notification Architecture

### System Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    User Browser                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ         Next.js Application                ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ  1. Request permission                      ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ  2. Subscribe to push                       ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ  3. Send subscription to backend            ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ                  ‚îÇ                                       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ         Service Worker                      ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ  - Listen for push events                   ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ  - Display notifications                    ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ  - Handle notification clicks               ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
                   ‚îÇ (Web Push Protocol)
                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            Push Service (Browser Vendor)                ‚îÇ
‚îÇ  - Chrome: FCM (Firebase Cloud Messaging)              ‚îÇ
‚îÇ  - Firefox: Mozilla Push Service                       ‚îÇ
‚îÇ  - Safari: Apple Push Notification Service             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
                   ‚îÇ (VAPID Protocol)
                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Backend Server (Express)                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ  Push Notification Service                 ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ  1. Store subscriptions in database        ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ  2. Trigger notifications on events        ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ  3. Send to push service via web-push      ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ  PostgreSQL Database                        ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ  - PushSubscription table                   ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ  - NotificationPreference table             ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìù Implementation Guide

### Phase 1: Backend Setup

#### Step 1.1: Install Dependencies

```bash
cd backend
pnpm install web-push
```

#### Step 1.2: Generate VAPID Keys

```bash
npx web-push generate-vapid-keys
```

Save the output to `.env`:

```env
VAPID_PUBLIC_KEY=BKxxx...
VAPID_PRIVATE_KEY=xxx...
VAPID_SUBJECT=mailto:admin@phhealth.com
```

#### Step 1.3: Create Database Schema

**File**: `backend/prisma/schema.prisma`

```prisma
model PushSubscription {
  id        String   @id @default(uuid())
  userId    String
  endpoint  String   @unique
  p256dh    String   // Encryption key
  auth      String   // Authentication secret
  userAgent String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("push_subscriptions")
}

model NotificationPreference {
  id                      String   @id @default(uuid())
  userId                  String   @unique
  appointmentReminders    Boolean  @default(true)
  newMessages             Boolean  @default(true)
  prescriptionUpdates     Boolean  @default(true)
  paymentReminders        Boolean  @default(true)
  appointmentConfirmation Boolean  @default(true)
  quietHoursStart         Int?     // 22 = 10 PM
  quietHoursEnd           Int?     // 8 = 8 AM
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
}
```

Run migration:

```bash
npx prisma migrate dev --name add_push_notifications
```

#### Step 1.4: Create Push Service

**File**: `backend/src/app/modules/Push/push.service.ts`

```typescript
import webPush from "web-push";
import prisma from "../../shared/prisma";
import config from "../../config";

// Configure web-push
webPush.setVapidDetails(
  config.vapid.subject,
  config.vapid.publicKey,
  config.vapid.privateKey
);

interface PushSubscriptionData {
  endpoint: string;
  keys: {
    p256dh: string;
    auth: string;
  };
}

interface NotificationPayload {
  title: string;
  body: string;
  icon?: string;
  badge?: string;
  image?: string;
  data?: any;
  actions?: Array<{
    action: string;
    title: string;
    icon?: string;
  }>;
  tag?: string;
  requireInteraction?: boolean;
}

/**
 * Subscribe user to push notifications
 */
const subscribe = async (
  userId: string,
  subscription: PushSubscriptionData,
  userAgent?: string
) => {
  // Check if subscription already exists
  const existing = await prisma.pushSubscription.findUnique({
    where: { endpoint: subscription.endpoint },
  });

  if (existing) {
    // Update existing subscription
    return await prisma.pushSubscription.update({
      where: { endpoint: subscription.endpoint },
      data: {
        p256dh: subscription.keys.p256dh,
        auth: subscription.keys.auth,
        userAgent,
        isActive: true,
      },
    });
  }

  // Create new subscription
  return await prisma.pushSubscription.create({
    data: {
      userId,
      endpoint: subscription.endpoint,
      p256dh: subscription.keys.p256dh,
      auth: subscription.keys.auth,
      userAgent,
    },
  });
};

/**
 * Unsubscribe from push notifications
 */
const unsubscribe = async (endpoint: string) => {
  return await prisma.pushSubscription.delete({
    where: { endpoint },
  });
};

/**
 * Get user's active subscriptions
 */
const getUserSubscriptions = async (userId: string) => {
  return await prisma.pushSubscription.findMany({
    where: {
      userId,
      isActive: true,
    },
  });
};

/**
 * Send push notification to user
 */
const sendToUser = async (userId: string, payload: NotificationPayload) => {
  // Get user's notification preferences
  const preferences = await prisma.notificationPreference.findUnique({
    where: { userId },
  });

  // Check quiet hours
  if (preferences) {
    const currentHour = new Date().getHours();
    if (
      preferences.quietHoursStart &&
      preferences.quietHoursEnd &&
      (currentHour >= preferences.quietHoursStart ||
        currentHour < preferences.quietHoursEnd)
    ) {
      console.log(`Skipping notification for user ${userId} - quiet hours`);
      return;
    }
  }

  // Get active subscriptions
  const subscriptions = await getUserSubscriptions(userId);

  if (subscriptions.length === 0) {
    console.log(`No active subscriptions for user ${userId}`);
    return;
  }

  // Send to all subscriptions
  const results = await Promise.allSettled(
    subscriptions.map(async (sub) => {
      try {
        await webPush.sendNotification(
          {
            endpoint: sub.endpoint,
            keys: {
              p256dh: sub.p256dh,
              auth: sub.auth,
            },
          },
          JSON.stringify(payload)
        );
        return { success: true, endpoint: sub.endpoint };
      } catch (error: any) {
        // Handle expired subscriptions
        if (error.statusCode === 410 || error.statusCode === 404) {
          await prisma.pushSubscription.update({
            where: { endpoint: sub.endpoint },
            data: { isActive: false },
          });
        }
        throw error;
      }
    })
  );

  return results;
};

/**
 * Send appointment reminder notification
 */
const sendAppointmentReminder = async (
  userId: string,
  appointmentId: string,
  doctorName: string,
  timeInMinutes: number
) => {
  const payload: NotificationPayload = {
    title: "Appointment Reminder",
    body: `Your appointment with ${doctorName} is in ${timeInMinutes} minutes`,
    icon: "/icons/appointment-icon.png",
    badge: "/icons/badge-icon.png",
    tag: `appointment-${appointmentId}`,
    requireInteraction: true,
    data: {
      type: "APPOINTMENT_REMINDER",
      appointmentId,
      url: `/dashboard/my-appointments/${appointmentId}`,
    },
    actions: [
      {
        action: "view",
        title: "View Details",
        icon: "/icons/view-icon.png",
      },
      {
        action: "dismiss",
        title: "Dismiss",
      },
    ],
  };

  return await sendToUser(userId, payload);
};

/**
 * Send new message notification
 */
const sendNewMessageNotification = async (
  userId: string,
  senderName: string,
  messagePreview: string,
  conversationId: string
) => {
  const payload: NotificationPayload = {
    title: `New message from ${senderName}`,
    body: messagePreview,
    icon: "/icons/message-icon.png",
    badge: "/icons/badge-icon.png",
    tag: `message-${conversationId}`,
    data: {
      type: "NEW_MESSAGE",
      conversationId,
      url: `/dashboard/messages/${conversationId}`,
    },
    actions: [
      {
        action: "reply",
        title: "Reply",
        icon: "/icons/reply-icon.png",
      },
      {
        action: "view",
        title: "View",
      },
    ],
  };

  return await sendToUser(userId, payload);
};

/**
 * Update notification preferences
 */
const updatePreferences = async (
  userId: string,
  preferences: Partial<{
    appointmentReminders: boolean;
    newMessages: boolean;
    prescriptionUpdates: boolean;
    paymentReminders: boolean;
    appointmentConfirmation: boolean;
    quietHoursStart: number;
    quietHoursEnd: number;
  }>
) => {
  return await prisma.notificationPreference.upsert({
    where: { userId },
    create: {
      userId,
      ...preferences,
    },
    update: preferences,
  });
};

/**
 * Get notification preferences
 */
const getPreferences = async (userId: string) => {
  return await prisma.notificationPreference.findUnique({
    where: { userId },
  });
};

export const PushService = {
  subscribe,
  unsubscribe,
  getUserSubscriptions,
  sendToUser,
  sendAppointmentReminder,
  sendNewMessageNotification,
  updatePreferences,
  getPreferences,
};
```

#### Step 1.5: Create Push Controller

**File**: `backend/src/app/modules/Push/push.controller.ts`

```typescript
import { Request, Response } from "express";
import catchAsync from "../../shared/catchAsync";
import sendResponse from "../../shared/sendResponse";
import { PushService } from "./push.service";

const subscribe = catchAsync(async (req: Request, res: Response) => {
  const userId = req.user.userId;
  const { subscription } = req.body;
  const userAgent = req.get("User-Agent");

  const result = await PushService.subscribe(userId, subscription, userAgent);

  sendResponse(res, {
    statusCode: 200,
    success: true,
    message: "Successfully subscribed to push notifications",
    data: result,
  });
});

const unsubscribe = catchAsync(async (req: Request, res: Response) => {
  const { endpoint } = req.body;

  await PushService.unsubscribe(endpoint);

  sendResponse(res, {
    statusCode: 200,
    success: true,
    message: "Successfully unsubscribed from push notifications",
  });
});

const updatePreferences = catchAsync(async (req: Request, res: Response) => {
  const userId = req.user.userId;

  const result = await PushService.updatePreferences(userId, req.body);

  sendResponse(res, {
    statusCode: 200,
    success: true,
    message: "Notification preferences updated",
    data: result,
  });
});

const getPreferences = catchAsync(async (req: Request, res: Response) => {
  const userId = req.user.userId;

  const result = await PushService.getPreferences(userId);

  sendResponse(res, {
    statusCode: 200,
    success: true,
    message: "Notification preferences retrieved",
    data: result,
  });
});

export const PushController = {
  subscribe,
  unsubscribe,
  updatePreferences,
  getPreferences,
};
```

#### Step 1.6: Create Routes

**File**: `backend/src/app/modules/Push/push.routes.ts`

```typescript
import express from "express";
import auth from "../../middlewares/auth";
import { PushController } from "./push.controller";
import { UserRole } from "@prisma/client";

const router = express.Router();

router.post(
  "/subscribe",
  auth(UserRole.PATIENT, UserRole.DOCTOR, UserRole.ADMIN),
  PushController.subscribe
);

router.post(
  "/unsubscribe",
  auth(UserRole.PATIENT, UserRole.DOCTOR, UserRole.ADMIN),
  PushController.unsubscribe
);

router.get(
  "/preferences",
  auth(UserRole.PATIENT, UserRole.DOCTOR, UserRole.ADMIN),
  PushController.getPreferences
);

router.patch(
  "/preferences",
  auth(UserRole.PATIENT, UserRole.DOCTOR, UserRole.ADMIN),
  PushController.updatePreferences
);

export const PushRoutes = router;
```

---

### Phase 2: Frontend Service Worker

#### Step 2.1: Create Service Worker

**File**: `frontend/public/sw.js`

```javascript
/* eslint-disable no-restricted-globals */

// Service Worker for Push Notifications

self.addEventListener("install", (event) => {
  console.log("Service Worker installing...");
  self.skipWaiting();
});

self.addEventListener("activate", (event) => {
  console.log("Service Worker activating...");
  event.waitUntil(self.clients.claim());
});

// Handle push events
self.addEventListener("push", (event) => {
  console.log("Push received:", event);

  if (!event.data) {
    console.log("Push event has no data");
    return;
  }

  const data = event.data.json();
  const {
    title,
    body,
    icon,
    badge,
    image,
    actions,
    tag,
    requireInteraction,
    data: payloadData,
  } = data;

  const options = {
    body,
    icon: icon || "/icons/default-icon.png",
    badge: badge || "/icons/badge-icon.png",
    image,
    tag: tag || "default-tag",
    requireInteraction: requireInteraction || false,
    data: payloadData,
    actions: actions || [],
    vibrate: [200, 100, 200],
  };

  event.waitUntil(self.registration.showNotification(title, options));
});

// Handle notification clicks
self.addEventListener("notificationclick", (event) => {
  console.log("Notification clicked:", event);

  event.notification.close();

  const action = event.action;
  const data = event.notification.data;

  let url = "/";

  if (action === "view" && data?.url) {
    url = data.url;
  } else if (action === "reply") {
    url = data?.url || "/dashboard/messages";
  } else if (data?.url) {
    url = data.url;
  }

  event.waitUntil(
    clients
      .matchAll({ type: "window", includeUncontrolled: true })
      .then((clientList) => {
        // Check if there's already a window open
        for (const client of clientList) {
          if (client.url.includes(url) && "focus" in client) {
            return client.focus();
          }
        }
        // Open new window
        if (clients.openWindow) {
          return clients.openWindow(url);
        }
      })
  );
});

// Handle notification close
self.addEventListener("notificationclose", (event) => {
  console.log("Notification closed:", event);
});
```

#### Step 2.2: Register Service Worker

**File**: `frontend/src/lib/registerServiceWorker.ts`

```typescript
export async function registerServiceWorker(): Promise<ServiceWorkerRegistration | null> {
  if (!("serviceWorker" in navigator)) {
    console.warn("Service Worker not supported");
    return null;
  }

  try {
    const registration = await navigator.serviceWorker.register("/sw.js", {
      scope: "/",
    });

    console.log("Service Worker registered:", registration);

    // Check for updates
    registration.addEventListener("updatefound", () => {
      console.log("Service Worker update found");
    });

    return registration;
  } catch (error) {
    console.error("Service Worker registration failed:", error);
    return null;
  }
}

export async function unregisterServiceWorker(): Promise<boolean> {
  if (!("serviceWorker" in navigator)) {
    return false;
  }

  try {
    const registration = await navigator.serviceWorker.getRegistration();
    if (registration) {
      return await registration.unregister();
    }
    return false;
  } catch (error) {
    console.error("Service Worker unregistration failed:", error);
    return false;
  }
}
```

#### Step 2.3: Create Push Notification Utilities

**File**: `frontend/src/lib/pushNotifications.ts`

```typescript
import { registerServiceWorker } from "./registerServiceWorker";

const VAPID_PUBLIC_KEY = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!;

function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");

  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);

  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}

export async function requestNotificationPermission(): Promise<NotificationPermission> {
  if (!("Notification" in window)) {
    console.warn("Notifications not supported");
    return "denied";
  }

  if (Notification.permission === "granted") {
    return "granted";
  }

  if (Notification.permission === "denied") {
    return "denied";
  }

  return await Notification.requestPermission();
}

export async function subscribeToPush(
  accessToken: string
): Promise<PushSubscription | null> {
  try {
    // Request permission
    const permission = await requestNotificationPermission();
    if (permission !== "granted") {
      console.log("Notification permission not granted");
      return null;
    }

    // Register service worker
    const registration = await registerServiceWorker();
    if (!registration) {
      console.error("Service Worker registration failed");
      return null;
    }

    // Subscribe to push
    const subscription = await registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY),
    });

    // Send subscription to backend
    const response = await fetch(
      `${process.env.NEXT_PUBLIC_API_URL}/api/v1/push/subscribe`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${accessToken}`,
        },
        body: JSON.stringify({ subscription }),
      }
    );

    if (!response.ok) {
      throw new Error("Failed to send subscription to server");
    }

    console.log("Successfully subscribed to push notifications");
    return subscription;
  } catch (error) {
    console.error("Failed to subscribe to push:", error);
    return null;
  }
}

export async function unsubscribeFromPush(
  accessToken: string
): Promise<boolean> {
  try {
    const registration = await navigator.serviceWorker.getRegistration();
    if (!registration) {
      return false;
    }

    const subscription = await registration.pushManager.getSubscription();
    if (!subscription) {
      return false;
    }

    // Unsubscribe from backend
    await fetch(`${process.env.NEXT_PUBLIC_API_URL}/api/v1/push/unsubscribe`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${accessToken}`,
      },
      body: JSON.stringify({ endpoint: subscription.endpoint }),
    });

    // Unsubscribe from browser
    const unsubscribed = await subscription.unsubscribe();
    console.log("Unsubscribed from push notifications");
    return unsubscribed;
  } catch (error) {
    console.error("Failed to unsubscribe from push:", error);
    return false;
  }
}

export async function isPushSubscribed(): Promise<boolean> {
  try {
    const registration = await navigator.serviceWorker.getRegistration();
    if (!registration) {
      return false;
    }

    const subscription = await registration.pushManager.getSubscription();
    return subscription !== null;
  } catch (error) {
    console.error("Failed to check push subscription:", error);
    return false;
  }
}
```

---

### Phase 3: Frontend Components

#### Step 3.1: Notification Settings Component

**File**: `frontend/src/components/NotificationSettings.tsx`

```typescript
"use client";

import { useState, useEffect } from "react";
import { Switch } from "@/components/ui/switch";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import {
  subscribeToPush,
  unsubscribeFromPush,
  isPushSubscribed,
} from "@/lib/pushNotifications";
import { Bell, BellOff } from "lucide-react";

interface NotificationPreferences {
  appointmentReminders: boolean;
  newMessages: boolean;
  prescriptionUpdates: boolean;
  paymentReminders: boolean;
  appointmentConfirmation: boolean;
  quietHoursStart: number | null;
  quietHoursEnd: number | null;
}

export default function NotificationSettings() {
  const [isSubscribed, setIsSubscribed] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [preferences, setPreferences] = useState<NotificationPreferences>({
    appointmentReminders: true,
    newMessages: true,
    prescriptionUpdates: true,
    paymentReminders: true,
    appointmentConfirmation: true,
    quietHoursStart: 22,
    quietHoursEnd: 8,
  });

  useEffect(() => {
    checkSubscriptionStatus();
    loadPreferences();
  }, []);

  const checkSubscriptionStatus = async () => {
    const subscribed = await isPushSubscribed();
    setIsSubscribed(subscribed);
  };

  const loadPreferences = async () => {
    try {
      const token = localStorage.getItem("accessToken");
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_URL}/api/v1/push/preferences`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (response.ok) {
        const data = await response.json();
        if (data.data) {
          setPreferences(data.data);
        }
      }
    } catch (error) {
      console.error("Failed to load preferences:", error);
    }
  };

  const handleTogglePush = async () => {
    setIsLoading(true);
    try {
      const token = localStorage.getItem("accessToken");
      if (!token) {
        alert("Please login first");
        return;
      }

      if (isSubscribed) {
        await unsubscribeFromPush(token);
        setIsSubscribed(false);
      } else {
        await subscribeToPush(token);
        setIsSubscribed(true);
      }
    } catch (error) {
      console.error("Failed to toggle push:", error);
      alert("Failed to update notification settings");
    } finally {
      setIsLoading(false);
    }
  };

  const handlePreferenceChange = async (
    key: keyof NotificationPreferences,
    value: boolean
  ) => {
    const updatedPreferences = { ...preferences, [key]: value };
    setPreferences(updatedPreferences);

    try {
      const token = localStorage.getItem("accessToken");
      await fetch(
        `${process.env.NEXT_PUBLIC_API_URL}/api/v1/push/preferences`,
        {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify({ [key]: value }),
        }
      );
    } catch (error) {
      console.error("Failed to update preference:", error);
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Bell className="h-5 w-5" />
          Push Notifications
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Enable/Disable Push */}
        <div className="flex items-center justify-between">
          <div>
            <Label className="text-base">Enable Push Notifications</Label>
            <p className="text-sm text-muted-foreground">
              Receive notifications even when the app is closed
            </p>
          </div>
          <Button
            onClick={handleTogglePush}
            disabled={isLoading}
            variant={isSubscribed ? "destructive" : "default"}
          >
            {isLoading ? (
              "Loading..."
            ) : isSubscribed ? (
              <>
                <BellOff className="mr-2 h-4 w-4" />
                Disable
              </>
            ) : (
              <>
                <Bell className="mr-2 h-4 w-4" />
                Enable
              </>
            )}
          </Button>
        </div>

        {/* Notification Preferences */}
        {isSubscribed && (
          <>
            <div className="space-y-4">
              <Label className="text-base">Notification Types</Label>

              <div className="flex items-center justify-between">
                <Label htmlFor="appointmentReminders">
                  Appointment Reminders
                </Label>
                <Switch
                  id="appointmentReminders"
                  checked={preferences.appointmentReminders}
                  onCheckedChange={(checked) =>
                    handlePreferenceChange("appointmentReminders", checked)
                  }
                />
              </div>

              <div className="flex items-center justify-between">
                <Label htmlFor="newMessages">New Messages</Label>
                <Switch
                  id="newMessages"
                  checked={preferences.newMessages}
                  onCheckedChange={(checked) =>
                    handlePreferenceChange("newMessages", checked)
                  }
                />
              </div>

              <div className="flex items-center justify-between">
                <Label htmlFor="prescriptionUpdates">
                  Prescription Updates
                </Label>
                <Switch
                  id="prescriptionUpdates"
                  checked={preferences.prescriptionUpdates}
                  onCheckedChange={(checked) =>
                    handlePreferenceChange("prescriptionUpdates", checked)
                  }
                />
              </div>

              <div className="flex items-center justify-between">
                <Label htmlFor="paymentReminders">Payment Reminders</Label>
                <Switch
                  id="paymentReminders"
                  checked={preferences.paymentReminders}
                  onCheckedChange={(checked) =>
                    handlePreferenceChange("paymentReminders", checked)
                  }
                />
              </div>

              <div className="flex items-center justify-between">
                <Label htmlFor="appointmentConfirmation">
                  Appointment Confirmations
                </Label>
                <Switch
                  id="appointmentConfirmation"
                  checked={preferences.appointmentConfirmation}
                  onCheckedChange={(checked) =>
                    handlePreferenceChange("appointmentConfirmation", checked)
                  }
                />
              </div>
            </div>
          </>
        )}
      </CardContent>
    </Card>
  );
}
```

---

## ‚úÖ Testing Checklist

### Backend

- [ ] Push subscription endpoint works
- [ ] VAPID keys configured correctly
- [ ] Subscriptions stored in database
- [ ] Notification preferences saved
- [ ] Push notifications sent successfully

### Frontend

- [ ] Service worker registers
- [ ] Permission request works
- [ ] Subscription to push works
- [ ] Notifications display correctly
- [ ] Notification clicks navigate properly
- [ ] Unsubscribe works

### Cross-Browser

- [ ] Chrome/Edge notifications work
- [ ] Firefox notifications work
- [ ] Safari notifications work (if supported)
- [ ] Mobile browser notifications work

---

## üéØ Acceptance Criteria

1. ‚úÖ Service worker registered
2. ‚úÖ Push subscription working
3. ‚úÖ Backend sends notifications via web-push
4. ‚úÖ Notifications display in browser
5. ‚úÖ Notification clicks work
6. ‚úÖ User preferences saved
7. ‚úÖ Quiet hours respected
8. ‚úÖ Expired subscriptions handled
9. ‚úÖ Multi-device support
10. ‚úÖ Graceful degradation on unsupported browsers

---

## üìñ Resources

- [Web Push API](https://developer.mozilla.org/en-US/docs/Web/API/Push_API)
- [Service Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)
- [web-push Library](https://github.com/web-push-libs/web-push)
- [Push Notifications Guide](https://web.dev/push-notifications-overview/)

---

**Task Status**: üìù Ready for implementation  
**Estimated Completion**: 1 week  
**Impact**: Improves engagement, real-time alerts, better user experience

---

_Keep users engaged with timely notifications!_ üîî
