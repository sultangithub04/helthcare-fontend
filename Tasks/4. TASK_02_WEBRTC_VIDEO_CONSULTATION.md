# Task 02: WebRTC Video Consultation System

## ðŸ“‹ Task Overview

**Difficulty**: ðŸŸ£ **EXPERT**  
**Estimated Time**: 2-3 weeks  
**Priority**: HIGH  
**Category**: Real-Time Communication

### Objective

Implement a fully functional video consultation system using WebRTC (with Daily.co free tier) that enables secure, high-quality video calls between doctors and patients with recording, screen sharing, and call quality monitoring capabilities.

### Learning Outcomes

- Master WebRTC fundamentals (STUN/TURN servers, ICE candidates, SDP)
- Implement peer-to-peer video/audio streaming
- Handle media permissions and device management
- Implement call signaling and connection management
- Build production-ready video UI with controls
- Understand NAT traversal and firewall issues
- Implement call recording and analytics

---

## ðŸŽ¯ Requirements

### Functional Requirements

1. **Video Call Features**

   - One-on-one video calls between doctor and patient
   - Audio mute/unmute toggle
   - Video on/off toggle
   - Screen sharing capability
   - Chat during call (text messages)
   - Call recording (optional, with consent)
   - Call timer/duration display
   - Network quality indicator
   - Participant list (for future group calls)

2. **Call Lifecycle**
   | Stage | Actions | Notifications |
   |-------|---------|---------------|
   | Pre-call | Check devices, test connection | Device permission prompts |
   | Initiating | Send call invite | WebSocket notification to doctor |
   | Ringing | Display caller info | Ring tone, visual indicator |
   | Active | Video/audio streaming | Call timer, quality indicator |
   | Ending | Cleanup resources | Call summary, rating prompt |
   | Post-call | Save call logs | Email receipt, add to history |

3. **Access Control**

   - Only scheduled appointments can initiate calls
   - Call available 10 minutes before appointment time
   - Automatic call termination after appointment slot
   - Doctor must join within 5 minutes or auto-cancel
   - Prevent unauthorized access to video rooms

4. **Call Quality**
   - Adaptive bitrate based on network
   - Automatic quality downgrade on poor connection
   - Echo cancellation
   - Noise suppression
   - Auto-reconnect on temporary disconnection

### Technical Requirements

1. **Technology Stack**

   - **Free Option 1**: Daily.co (10K minutes/month free)

     - Managed TURN servers
     - Built-in recording
     - Great documentation
     - Mobile SDK available

   - **Free Option 2**: Self-hosted Jitsi Meet
     - Fully open source
     - Self-hosted control
     - No usage limits
     - More complex setup

   **Recommended**: Daily.co for faster development, Jitsi for cost control at scale

2. **Integration Points**

   - Appointment system (trigger call button)
   - Notification system (call invites)
   - Payment verification (paid appointments only)
   - Prescription module (post-call prescription)

3. **Performance Targets**
   - Video latency < 300ms
   - Audio latency < 150ms
   - Call establishment < 3 seconds
   - Support up to 720p video quality
   - < 5% packet loss tolerance

---

## ðŸ—ï¸ Architecture Design

### System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Patient Client â”‚                    â”‚  Doctor Client  â”‚
â”‚   (Browser)     â”‚                    â”‚   (Browser)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                                      â”‚
         â”‚  1. Request Video Token              â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
         â”‚                                      â”‚
         â–¼                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             Backend API Server                          â”‚
â”‚  - Verify appointment & payment                        â”‚
â”‚  - Generate Daily.co room token                        â”‚
â”‚  - Store call metadata                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â”‚  2. Room Token
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Daily.co Service                       â”‚
â”‚  - WebRTC signaling (STUN/TURN)                        â”‚
â”‚  - Media relay servers                                 â”‚
â”‚  - Recording infrastructure                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â”‚  3. Media Streams (P2P or relayed)
                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                         â”‚
    â–¼                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Patientâ”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Doctor â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜   Video/Audio â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Flow

```
1. Patient clicks "Start Video Call" on appointment
        â†“
2. Frontend validates:
   - Is appointment within allowed time window?
   - Is payment completed?
   - Are devices accessible?
        â†“
3. Backend creates Daily.co room:
   - POST /api/v1/video/create-room
   - Stores room info in database
        â†“
4. Backend generates access tokens:
   - Patient token with join permission
   - Doctor token with owner permission
        â†“
5. Frontend initializes Daily.co SDK:
   - Loads iframe/component
   - Joins room with token
        â†“
6. WebRTC connection established:
   - STUN/TURN negotiation
   - ICE candidates exchange
   - Media streams connected
        â†“
7. Call active - streaming video/audio
        â†“
8. Call ends - cleanup:
   - Update appointment status
   - Save call duration
   - Request prescription (if needed)
   - Prompt for review
```

---

## ðŸ“ Implementation Guide

### Phase 1: Daily.co Setup

#### Step 1.1: Create Daily.co Account

1. Visit [Daily.co](https://daily.co) and sign up (free tier: 10K minutes/month)
2. Get API key from dashboard
3. Note your domain: `yourdomain.daily.co`

#### Step 1.2: Install Daily.co SDK

**Backend**:

```bash
cd backend
pnpm install @daily-co/daily-js axios
```

**Frontend**:

```bash
cd frontend
npm install @daily-co/daily-react @daily-co/daily-js
```

#### Step 1.3: Configure Environment Variables

**Backend `.env`**:

```env
DAILY_API_KEY=your_daily_api_key_here
DAILY_DOMAIN=yourdomain.daily.co
```

**Frontend `.env.local`**:

```env
NEXT_PUBLIC_DAILY_DOMAIN=yourdomain.daily.co
```

---

### Phase 2: Backend Implementation

#### Step 2.1: Create Video Call Service

**File**: `backend/src/app/modules/VideoCall/videoCall.service.ts`

```typescript
import axios from "axios";
import config from "../../../config";
import prisma from "../../../shared/prisma";
import ApiError from "../../errors/ApiError";
import httpStatus from "http-status";
import { AppointmentStatus, PaymentStatus } from "@prisma/client";

const DAILY_API_URL = "https://api.daily.co/v1";

interface CreateRoomOptions {
  appointmentId: string;
  userId: string;
  userRole: "PATIENT" | "DOCTOR";
}

const createVideoRoom = async (options: CreateRoomOptions) => {
  const { appointmentId, userId, userRole } = options;

  // Verify appointment
  const appointment = await prisma.appointment.findUnique({
    where: { id: appointmentId },
    include: {
      patient: true,
      doctor: true,
      schedule: true,
      payment: true,
    },
  });

  if (!appointment) {
    throw new ApiError(httpStatus.NOT_FOUND, "Appointment not found");
  }

  // Verify payment
  if (appointment.paymentStatus !== PaymentStatus.PAID) {
    throw new ApiError(httpStatus.FORBIDDEN, "Payment not completed");
  }

  // Verify user is part of appointment
  if (appointment.patientId !== userId && appointment.doctorId !== userId) {
    throw new ApiError(httpStatus.FORBIDDEN, "Unauthorized access");
  }

  // Check if call window is valid (10 min before to appointment end)
  const now = new Date();
  const scheduleStart = new Date(appointment.schedule.startDateTime);
  const scheduleEnd = new Date(appointment.schedule.endDateTime);
  const callWindowStart = new Date(scheduleStart.getTime() - 10 * 60 * 1000);

  if (now < callWindowStart) {
    throw new ApiError(
      httpStatus.FORBIDDEN,
      `Call available from ${callWindowStart.toLocaleString()}`
    );
  }

  if (now > scheduleEnd) {
    throw new ApiError(httpStatus.FORBIDDEN, "Appointment time has passed");
  }

  // Check if room already exists
  let videoCall = await prisma.videoCall.findFirst({
    where: { appointmentId },
  });

  if (!videoCall) {
    // Create Daily.co room
    const roomResponse = await axios.post(
      `${DAILY_API_URL}/rooms`,
      {
        properties: {
          exp: Math.floor(scheduleEnd.getTime() / 1000), // Room expires at appointment end
          enable_chat: true,
          enable_screenshare: true,
          enable_recording: "cloud", // Enable cloud recording
          max_participants: 2, // Only doctor and patient
          enable_knocking: false,
          enable_prejoin_ui: false,
        },
      },
      {
        headers: {
          Authorization: `Bearer ${config.dailyApiKey}`,
          "Content-Type": "application/json",
        },
      }
    );

    const roomName = roomResponse.data.name;
    const roomUrl = roomResponse.data.url;

    // Save to database
    videoCall = await prisma.videoCall.create({
      data: {
        appointmentId,
        roomName,
        roomUrl,
        status: "CREATED",
      },
    });
  }

  // Generate user-specific token
  const tokenResponse = await axios.post(
    `${DAILY_API_URL}/meeting-tokens`,
    {
      properties: {
        room_name: videoCall.roomName,
        user_name:
          userRole === "PATIENT"
            ? appointment.patient.name
            : appointment.doctor.name,
        is_owner: userRole === "DOCTOR", // Doctor has owner privileges
        enable_recording: userRole === "DOCTOR" ? "cloud" : undefined,
        exp: Math.floor(scheduleEnd.getTime() / 1000),
      },
    },
    {
      headers: {
        Authorization: `Bearer ${config.dailyApiKey}`,
        "Content-Type": "application/json",
      },
    }
  );

  return {
    roomUrl: videoCall.roomUrl,
    token: tokenResponse.data.token,
    videoCallId: videoCall.id,
    expiresAt: scheduleEnd.toISOString(),
  };
};

const endVideoCall = async (videoCallId: string, userId: string) => {
  const videoCall = await prisma.videoCall.findUnique({
    where: { id: videoCallId },
    include: {
      appointment: {
        include: { patient: true, doctor: true },
      },
    },
  });

  if (!videoCall) {
    throw new ApiError(httpStatus.NOT_FOUND, "Video call not found");
  }

  // Verify user is participant
  if (
    videoCall.appointment.patientId !== userId &&
    videoCall.appointment.doctorId !== userId
  ) {
    throw new ApiError(httpStatus.FORBIDDEN, "Unauthorized");
  }

  // Update call status
  const updatedCall = await prisma.videoCall.update({
    where: { id: videoCallId },
    data: {
      status: "COMPLETED",
      endedAt: new Date(),
    },
  });

  // Update appointment status
  await prisma.appointment.update({
    where: { id: videoCall.appointmentId },
    data: {
      status: AppointmentStatus.COMPLETED,
    },
  });

  // Delete Daily.co room
  try {
    await axios.delete(`${DAILY_API_URL}/rooms/${videoCall.roomName}`, {
      headers: {
        Authorization: `Bearer ${config.dailyApiKey}`,
      },
    });
  } catch (error) {
    console.error("Error deleting Daily.co room:", error);
  }

  return updatedCall;
};

const getCallRecording = async (videoCallId: string, userId: string) => {
  const videoCall = await prisma.videoCall.findUnique({
    where: { id: videoCallId },
    include: {
      appointment: true,
    },
  });

  if (!videoCall) {
    throw new ApiError(httpStatus.NOT_FOUND, "Video call not found");
  }

  // Verify access
  if (
    videoCall.appointment.patientId !== userId &&
    videoCall.appointment.doctorId !== userId
  ) {
    throw new ApiError(httpStatus.FORBIDDEN, "Unauthorized");
  }

  // Get recordings from Daily.co
  const response = await axios.get(
    `${DAILY_API_URL}/recordings?room_name=${videoCall.roomName}`,
    {
      headers: {
        Authorization: `Bearer ${config.dailyApiKey}`,
      },
    }
  );

  return response.data.data || [];
};

export const VideoCallService = {
  createVideoRoom,
  endVideoCall,
  getCallRecording,
};
```

#### Step 2.2: Create Video Call Controller

**File**: `backend/src/app/modules/VideoCall/videoCall.controller.ts`

```typescript
import { Request, Response } from "express";
import catchAsync from "../../../shared/catchAsync";
import sendResponse from "../../../shared/sendResponse";
import httpStatus from "http-status";
import { VideoCallService } from "./videoCall.service";

const createRoom = catchAsync(async (req: Request, res: Response) => {
  const { appointmentId } = req.body;
  const user = (req as any).user;

  const result = await VideoCallService.createVideoRoom({
    appointmentId,
    userId: user.userId,
    userRole: user.role,
  });

  sendResponse(res, {
    statusCode: httpStatus.OK,
    success: true,
    message: "Video room created successfully",
    data: result,
  });
});

const endCall = catchAsync(async (req: Request, res: Response) => {
  const { videoCallId } = req.params;
  const user = (req as any).user;

  const result = await VideoCallService.endVideoCall(videoCallId, user.userId);

  sendResponse(res, {
    statusCode: httpStatus.OK,
    success: true,
    message: "Video call ended successfully",
    data: result,
  });
});

const getRecording = catchAsync(async (req: Request, res: Response) => {
  const { videoCallId } = req.params;
  const user = (req as any).user;

  const result = await VideoCallService.getCallRecording(
    videoCallId,
    user.userId
  );

  sendResponse(res, {
    statusCode: httpStatus.OK,
    success: true,
    message: "Recordings retrieved successfully",
    data: result,
  });
});

export const VideoCallController = {
  createRoom,
  endCall,
  getRecording,
};
```

#### Step 2.3: Create Routes

**File**: `backend/src/app/modules/VideoCall/videoCall.routes.ts`

```typescript
import express from "express";
import auth from "../../middlewares/auth";
import { VideoCallController } from "./videoCall.controller";
import { UserRole } from "@prisma/client";

const router = express.Router();

router.post(
  "/create-room",
  auth(UserRole.PATIENT, UserRole.DOCTOR),
  VideoCallController.createRoom
);

router.patch(
  "/:videoCallId/end",
  auth(UserRole.PATIENT, UserRole.DOCTOR),
  VideoCallController.endCall
);

router.get(
  "/:videoCallId/recordings",
  auth(UserRole.PATIENT, UserRole.DOCTOR),
  VideoCallController.getRecording
);

export const VideoCallRoutes = router;
```

#### Step 2.4: Add Prisma Schema

**File**: `backend/prisma/schema/videoCall.prisma`

```prisma
model VideoCall {
  id            String   @id @default(uuid())
  appointmentId String   @unique
  appointment   Appointment @relation(fields: [appointmentId], references: [id])

  roomName      String   @unique
  roomUrl       String
  status        VideoCallStatus @default(CREATED)

  startedAt     DateTime @default(now())
  endedAt       DateTime?
  duration      Int?      // Duration in seconds

  recordingUrl  String?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([appointmentId])
  @@index([status])
  @@map("video_calls")
}

enum VideoCallStatus {
  CREATED
  IN_PROGRESS
  COMPLETED
  FAILED
  CANCELLED
}
```

Update Appointment model:

```prisma
model Appointment {
  // ... existing fields
  videoCall VideoCall?
}
```

Run migration:

```bash
pnpm db:push
```

---

### Phase 3: Frontend Implementation

#### Step 3.1: Create Video Call Component

**File**: `src/components/modules/VideoCall/VideoCallRoom.tsx`

```tsx
"use client";

import { useDaily, DailyProvider } from "@daily-co/daily-react";
import { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import {
  Mic,
  MicOff,
  Video,
  VideoOff,
  Phone,
  Monitor,
  MessageSquare,
  Settings,
} from "lucide-react";

interface VideoCallRoomProps {
  roomUrl: string;
  token: string;
  onLeave: () => void;
}

function CallUI({ onLeave }: { onLeave: () => void }) {
  const daily = useDaily();
  const [isMicOn, setIsMicOn] = useState(true);
  const [isCameraOn, setIsCameraOn] = useState(true);
  const [isScreenSharing, setIsScreenSharing] = useState(false);
  const [participants, setParticipants] = useState<any[]>([]);
  const [callDuration, setCallDuration] = useState(0);

  useEffect(() => {
    if (!daily) return;

    // Join call
    daily.join();

    // Event listeners
    const handleParticipantJoined = (event: any) => {
      console.log("Participant joined:", event.participant);
      setParticipants((prev) => [...prev, event.participant]);
    };

    const handleParticipantLeft = (event: any) => {
      console.log("Participant left:", event.participant);
      setParticipants((prev) =>
        prev.filter((p) => p.session_id !== event.participant.session_id)
      );
    };

    const handleError = (event: any) => {
      console.error("Daily error:", event);
    };

    daily.on("participant-joined", handleParticipantJoined);
    daily.on("participant-left", handleParticipantLeft);
    daily.on("error", handleError);

    // Call duration timer
    const interval = setInterval(() => {
      setCallDuration((prev) => prev + 1);
    }, 1000);

    return () => {
      clearInterval(interval);
      daily.off("participant-joined", handleParticipantJoined);
      daily.off("participant-left", handleParticipantLeft);
      daily.off("error", handleError);
    };
  }, [daily]);

  const toggleMic = () => {
    if (daily) {
      daily.setLocalAudio(!isMicOn);
      setIsMicOn(!isMicOn);
    }
  };

  const toggleCamera = () => {
    if (daily) {
      daily.setLocalVideo(!isCameraOn);
      setIsCameraOn(!isCameraOn);
    }
  };

  const toggleScreenShare = () => {
    if (daily) {
      if (isScreenSharing) {
        daily.stopScreenShare();
      } else {
        daily.startScreenShare();
      }
      setIsScreenSharing(!isScreenSharing);
    }
  };

  const leaveCall = () => {
    if (daily) {
      daily.leave();
      onLeave();
    }
  };

  const formatDuration = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, "0")}:${secs
      .toString()
      .padStart(2, "0")}`;
  };

  return (
    <div className="relative h-screen bg-gray-900">
      {/* Video Grid */}
      <div className="absolute inset-0">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-2 h-full p-4">
          {/* Local video */}
          <div className="relative bg-gray-800 rounded-lg overflow-hidden">
            <video
              id="local-video"
              autoPlay
              muted
              playsInline
              className="w-full h-full object-cover"
            />
            <div className="absolute bottom-4 left-4 text-white text-sm bg-black/50 px-3 py-1 rounded">
              You {!isCameraOn && "(Camera Off)"}
            </div>
          </div>

          {/* Remote video */}
          {participants.map((participant) => (
            <div
              key={participant.session_id}
              className="relative bg-gray-800 rounded-lg overflow-hidden"
            >
              <video
                id={`remote-video-${participant.session_id}`}
                autoPlay
                playsInline
                className="w-full h-full object-cover"
              />
              <div className="absolute bottom-4 left-4 text-white text-sm bg-black/50 px-3 py-1 rounded">
                {participant.user_name}
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Controls */}
      <div className="absolute bottom-0 left-0 right-0 p-6 bg-gradient-to-t from-black/80 to-transparent">
        <div className="flex items-center justify-between max-w-4xl mx-auto">
          {/* Call Duration */}
          <div className="text-white text-sm font-medium">
            {formatDuration(callDuration)}
          </div>

          {/* Main Controls */}
          <div className="flex gap-3">
            <Button
              variant={isMicOn ? "secondary" : "destructive"}
              size="icon"
              className="rounded-full h-12 w-12"
              onClick={toggleMic}
            >
              {isMicOn ? <Mic /> : <MicOff />}
            </Button>

            <Button
              variant={isCameraOn ? "secondary" : "destructive"}
              size="icon"
              className="rounded-full h-12 w-12"
              onClick={toggleCamera}
            >
              {isCameraOn ? <Video /> : <VideoOff />}
            </Button>

            <Button
              variant={isScreenSharing ? "default" : "secondary"}
              size="icon"
              className="rounded-full h-12 w-12"
              onClick={toggleScreenShare}
            >
              <Monitor />
            </Button>

            <Button
              variant="destructive"
              size="icon"
              className="rounded-full h-12 w-12"
              onClick={leaveCall}
            >
              <Phone className="rotate-135" />
            </Button>
          </div>

          {/* Secondary Controls */}
          <div className="flex gap-2">
            <Button variant="ghost" size="icon" className="text-white">
              <MessageSquare />
            </Button>
            <Button variant="ghost" size="icon" className="text-white">
              <Settings />
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}

export function VideoCallRoom({ roomUrl, token, onLeave }: VideoCallRoomProps) {
  return (
    <DailyProvider url={roomUrl} token={token}>
      <CallUI onLeave={onLeave} />
    </DailyProvider>
  );
}
```

#### Step 3.2: Create Video Call Button on Appointment

**File**: `src/components/modules/Patient/AppointmentCard.tsx`

```tsx
"use client";

import { useState } from "react";
import { Video } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent } from "@/components/ui/dialog";
import { VideoCallRoom } from "@/components/modules/VideoCall/VideoCallRoom";
import { createVideoRoom } from "@/services/videoCall.service";
import { toast } from "sonner";

interface AppointmentCardProps {
  appointment: any;
}

export function AppointmentCard({ appointment }: AppointmentCardProps) {
  const [showVideoCall, setShowVideoCall] = useState(false);
  const [videoCallData, setVideoCallData] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(false);

  const handleStartCall = async () => {
    setIsLoading(true);
    try {
      const data = await createVideoRoom(appointment.id);
      setVideoCallData(data);
      setShowVideoCall(true);
    } catch (error: any) {
      toast.error(error.message || "Failed to start video call");
    } finally {
      setIsLoading(false);
    }
  };

  const handleLeaveCall = () => {
    setShowVideoCall(false);
    setVideoCallData(null);
    // Optionally call end call API
  };

  // Check if call is available
  const now = new Date();
  const scheduleStart = new Date(appointment.schedule.startDateTime);
  const callWindowStart = new Date(scheduleStart.getTime() - 10 * 60 * 1000);
  const isCallAvailable =
    now >= callWindowStart &&
    appointment.paymentStatus === "PAID" &&
    appointment.status !== "COMPLETED";

  return (
    <>
      <div className="border rounded-lg p-4">
        {/* ... existing appointment details ... */}

        {isCallAvailable && (
          <Button
            onClick={handleStartCall}
            disabled={isLoading}
            className="w-full mt-4"
          >
            <Video className="mr-2 h-4 w-4" />
            {isLoading ? "Starting..." : "Start Video Consultation"}
          </Button>
        )}
      </div>

      {/* Video Call Dialog */}
      <Dialog open={showVideoCall} onOpenChange={setShowVideoCall}>
        <DialogContent className="max-w-full h-screen p-0">
          {videoCallData && (
            <VideoCallRoom
              roomUrl={videoCallData.roomUrl}
              token={videoCallData.token}
              onLeave={handleLeaveCall}
            />
          )}
        </DialogContent>
      </Dialog>
    </>
  );
}
```

#### Step 3.3: Create Video Call Service

**File**: `src/services/videoCall.service.ts`

```typescript
import { serverFetch } from "@/lib/server-fetch";

export async function createVideoRoom(appointmentId: string) {
  const response = await serverFetch.post("/video-call/create-room", {
    body: JSON.stringify({ appointmentId }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || "Failed to create video room");
  }

  const result = await response.json();
  return result.data;
}

export async function endVideoCall(videoCallId: string) {
  const response = await serverFetch.patch(`/video-call/${videoCallId}/end`);

  if (!response.ok) {
    throw new Error("Failed to end video call");
  }

  return response.json();
}

export async function getCallRecordings(videoCallId: string) {
  const response = await serverFetch.get(
    `/video-call/${videoCallId}/recordings`
  );

  if (!response.ok) {
    throw new Error("Failed to get recordings");
  }

  const result = await response.json();
  return result.data;
}
```

---

## âœ… Testing Checklist

### Functional Tests

- [ ] Patient can start video call for paid appointment
- [ ] Doctor receives call notification
- [ ] Video and audio streams work
- [ ] Mute/unmute controls work
- [ ] Camera on/off works
- [ ] Screen sharing works
- [ ] Call timer displays correctly
- [ ] Call ends gracefully
- [ ] Recording saves successfully
- [ ] Unauthorized users cannot join

### Edge Cases

- [ ] Poor network conditions
- [ ] Browser permission denied
- [ ] Device not available (no camera/mic)
- [ ] User leaves and rejoins
- [ ] Connection lost and reconnects
- [ ] Multiple browser tabs

### Performance Tests

- [ ] Call establishes within 3 seconds
- [ ] Video latency < 300ms
- [ ] Audio latency < 150ms
- [ ] Works on mobile devices
- [ ] Works on different browsers

---

## ðŸ“š Additional Features (Optional)

1. **Virtual Background**: Blur or replace background
2. **Beauty Filters**: Skin smoothing, lighting adjustment
3. **Waiting Room**: Pre-call device check
4. **Call Quality Metrics**: Display bitrate, fps, packet loss
5. **Picture-in-Picture**: Minimize video while browsing
6. **Live Transcription**: Speech-to-text during call
7. **Post-Call Survey**: Rate call quality

---

## ðŸŽ¯ Acceptance Criteria

- [ ] Video calls work reliably between doctor and patient
- [ ] Call quality is acceptable (clear video/audio)
- [ ] All controls (mute, camera, screen share) function properly
- [ ] Call recordings save successfully
- [ ] Access control prevents unauthorized joins
- [ ] Works on Chrome, Firefox, Safari, Edge
- [ ] Mobile responsive
- [ ] Documentation complete
- [ ] All tests pass

---

## ðŸ“– Resources

- [Daily.co Documentation](https://docs.daily.co/)
- [WebRTC Fundamentals](https://webrtc.org/getting-started/overview)
- [Daily React SDK](https://docs.daily.co/reference/daily-react)

---

**Next Task**: See `TASK_03_CHAT_SYSTEM.md`
