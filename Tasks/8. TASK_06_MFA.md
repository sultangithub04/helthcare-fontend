# Task 06: Multi-Factor Authentication (MFA) Implementation

## üìã Task Overview

**Difficulty**: üü° **INTERMEDIATE**  
**Estimated Time**: 1 week  
**Priority**: HIGH  
**Category**: Security Enhancements

### Objective

Implement Time-based One-Time Password (TOTP) Multi-Factor Authentication using Google Authenticator/Authy, providing a second layer of security for user accounts. Make MFA optional for patients, but mandatory for doctors and admins to protect sensitive medical data and administrative functions.

### Learning Outcomes

- Understand TOTP (Time-based One-Time Password) algorithm
- Implement QR code generation for authenticator apps
- Build secure MFA enrollment and verification flow
- Handle backup codes for account recovery
- Implement "Remember this device" functionality
- Design MFA-aware authentication flow

---

## üéØ Requirements

### Functional Requirements

1. **MFA Enrollment**
   | Step | Action | Security Measure |
   |------|--------|------------------|
   | 1. Enable MFA | User clicks "Enable 2FA" | Require password confirmation |
   | 2. Generate Secret | Create TOTP secret | Store encrypted in database |
   | 3. Display QR Code | Show QR for authenticator app | Use secure connection (HTTPS) |
   | 4. Verify Setup | User enters 6-digit code | Validate before activation |
   | 5. Backup Codes | Generate 10 backup codes | Display once, user must save |

2. **MFA Login Flow**

   - User enters email + password (step 1)
   - If MFA enabled ‚Üí Prompt for 6-digit code (step 2)
   - Validate TOTP code or backup code
   - Optional: "Trust this device for 30 days"
   - Grant access on successful verification

3. **Account Recovery**

   - Use backup codes if phone lost
   - Admin can reset MFA for users (with audit log)
   - Email verification required for MFA reset

4. **MFA Policy**
   - **Patients**: Optional (can enable for extra security)
   - **Doctors**: Mandatory (enforced on first login)
   - **Admins**: Mandatory (enforced on account creation)
   - Cannot access protected routes without MFA if required

### Technical Requirements

1. **Technology Stack**

   - **Backend**: `speakeasy` (TOTP library), `qrcode` (QR generation)
   - **Frontend**: `react-qr-code`, input masking for 6-digit code
   - **Database**: Store encrypted secrets, backup codes
   - **Algorithm**: TOTP (RFC 6238), SHA-1, 30-second window

2. **Security Requirements**

   - Encrypt TOTP secrets in database (AES-256)
   - Hash backup codes before storage (bcrypt)
   - Rate limit verification attempts (5 attempts/15 min)
   - Invalidate backup codes after use (one-time use)
   - Log all MFA events (enable, disable, failed attempts)
   - Implement time window tolerance (¬±1 period)

3. **Performance Targets**
   - QR code generation < 100ms
   - TOTP verification < 50ms
   - Support 10,000+ concurrent MFA verifications

---

## üèóÔ∏è MFA Flow Architecture

### Enrollment Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  User Dashboard     ‚îÇ
‚îÇ  Click "Enable 2FA" ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Password Confirmation Modal    ‚îÇ
‚îÇ  (Verify identity)              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ ‚úì Password correct
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Backend: Generate TOTP Secret  ‚îÇ
‚îÇ  - speakeasy.generateSecret()   ‚îÇ
‚îÇ  - Encrypt secret (AES-256)     ‚îÇ
‚îÇ  - Save to database (inactive)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Display QR Code + Manual Key   ‚îÇ
‚îÇ  - QR for scanning              ‚îÇ
‚îÇ  - Text key for manual entry    ‚îÇ
‚îÇ  - Instructions for user        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  User Scans with Authenticator  ‚îÇ
‚îÇ  (Google Authenticator, Authy)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  User Enters 6-Digit Code       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Backend: Verify Code           ‚îÇ
‚îÇ  - speakeasy.verify()           ‚îÇ
‚îÇ  - Window: ¬±1 (90 sec window)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ ‚úì Code valid
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Activate MFA                   ‚îÇ
‚îÇ  - Set isEnabled = true         ‚îÇ
‚îÇ  - Generate 10 backup codes     ‚îÇ
‚îÇ  - Display backup codes         ‚îÇ
‚îÇ  - Force user to download/save  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Login Flow with MFA

```
User Login (email + password)
           ‚îÇ
           ‚ñº
     Valid credentials?
           ‚îÇ
        ‚îå‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îê
        ‚îÇ  YES ‚îÇ
        ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
     MFA Enabled?
           ‚îÇ
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ   YES   ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
   Show MFA Challenge
   (Enter 6-digit code)
           ‚îÇ
           ‚ñº
   Backend: Verify Code
           ‚îÇ
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ  Valid? ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ YES
           ‚ñº
   Grant Access Token
   (Optional: Set trusted device cookie)
           ‚îÇ
           ‚ñº
   Redirect to Dashboard
```

---

## üìù Implementation Guide

### Phase 1: Database Schema

#### Step 1.1: Add MFA Schema

**File**: `backend/prisma/schema/mfa.prisma`

```prisma
model TwoFactorAuth {
  id        String   @id @default(uuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // TOTP Secret (encrypted)
  secret    String   // AES-256 encrypted secret
  secretIV  String   // Initialization vector for encryption

  // MFA Status
  isEnabled Boolean  @default(false)
  isVerified Boolean @default(false) // True after first successful verification

  // Metadata
  enabledAt DateTime?
  lastUsedAt DateTime?

  // Backup for QR code regeneration
  qrCodeUrl String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  backupCodes MFABackupCode[]

  @@map("two_factor_auth")
}

model MFABackupCode {
  id        String        @id @default(uuid())
  mfaId     String
  mfa       TwoFactorAuth @relation(fields: [mfaId], references: [id], onDelete: Cascade)

  // Backup code (hashed with bcrypt)
  codeHash  String

  // Usage tracking
  isUsed    Boolean       @default(false)
  usedAt    DateTime?
  usedIP    String?

  createdAt DateTime      @default(now())

  @@index([mfaId])
  @@map("mfa_backup_codes")
}

model TrustedDevice {
  id         String   @id @default(uuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  deviceId   String   @unique // SHA-256 hash of user agent + IP
  deviceName String   // Parsed device name
  ipAddress  String

  // Expiry
  expiresAt  DateTime // 30 days from creation

  createdAt  DateTime @default(now())
  lastUsedAt DateTime @default(now())

  @@index([userId])
  @@index([deviceId])
  @@map("trusted_devices")
}

model MFAAuditLog {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  action    MFAAction
  success   Boolean
  ipAddress String
  userAgent String?

  // Additional context
  metadata  Json?

  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@map("mfa_audit_logs")
}

enum MFAAction {
  MFA_ENABLED
  MFA_DISABLED
  MFA_VERIFIED
  MFA_FAILED
  BACKUP_CODE_USED
  BACKUP_CODE_REGENERATED
  DEVICE_TRUSTED
}
```

**Update User Model**:

```prisma
model User {
  // ... existing fields

  twoFactorAuth   TwoFactorAuth?
  trustedDevices  TrustedDevice[]
  mfaAuditLogs    MFAAuditLog[]
  mfaRequired     Boolean @default(false) // Mandatory for doctors/admins
}
```

**Run Migration**:

```bash
cd backend
pnpm prisma generate
pnpm prisma migrate dev --name add_mfa_support
```

---

### Phase 2: Backend Implementation

#### Step 2.1: Create MFA Service

**File**: `backend/src/app/modules/MFA/mfa.service.ts`

```typescript
import speakeasy from "speakeasy";
import QRCode from "qrcode";
import bcrypt from "bcrypt";
import crypto from "crypto";
import prisma from "../../../shared/prisma";
import ApiError from "../../errors/ApiError";
import httpStatus from "http-status";
import config from "../../../config";
import { encryptData, decryptData } from "../../../helpers/encryption";

const ENCRYPTION_KEY = config.mfaEncryptionKey; // 32 bytes
const APP_NAME = "PH-HealthCare";

/**
 * Generate TOTP secret and QR code
 */
const setupMFA = async (userId: string) => {
  // Check if already exists
  const existing = await prisma.twoFactorAuth.findUnique({
    where: { userId },
  });

  if (existing && existing.isEnabled) {
    throw new ApiError(
      httpStatus.BAD_REQUEST,
      "MFA is already enabled. Disable first to re-setup."
    );
  }

  // Get user details
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { email: true, name: true },
  });

  if (!user) {
    throw new ApiError(httpStatus.NOT_FOUND, "User not found");
  }

  // Generate TOTP secret
  const secret = speakeasy.generateSecret({
    name: `${APP_NAME} (${user.email})`,
    issuer: APP_NAME,
    length: 32,
  });

  // Encrypt secret before storage
  const { encrypted, iv } = encryptData(secret.base32);

  // Generate QR code
  const qrCodeUrl = await QRCode.toDataURL(secret.otpauth_url!);

  // Save to database (not yet enabled)
  const mfa = await prisma.twoFactorAuth.upsert({
    where: { userId },
    create: {
      userId,
      secret: encrypted,
      secretIV: iv,
      qrCodeUrl,
      isEnabled: false,
      isVerified: false,
    },
    update: {
      secret: encrypted,
      secretIV: iv,
      qrCodeUrl,
      isEnabled: false,
      isVerified: false,
    },
  });

  return {
    secret: secret.base32, // Send to frontend once for user to backup
    qrCode: qrCodeUrl,
    setupUri: secret.otpauth_url,
  };
};

/**
 * Verify TOTP code and enable MFA
 */
const verifyAndEnableMFA = async (userId: string, token: string) => {
  const mfa = await prisma.twoFactorAuth.findUnique({
    where: { userId },
  });

  if (!mfa) {
    throw new ApiError(
      httpStatus.NOT_FOUND,
      "MFA not setup. Call setup endpoint first."
    );
  }

  if (mfa.isEnabled) {
    throw new ApiError(httpStatus.BAD_REQUEST, "MFA already enabled");
  }

  // Decrypt secret
  const decryptedSecret = decryptData(mfa.secret, mfa.secretIV);

  // Verify token
  const verified = speakeasy.totp.verify({
    secret: decryptedSecret,
    encoding: "base32",
    token,
    window: 1, // Allow ¬±30 seconds (1 time step before/after)
  });

  if (!verified) {
    throw new ApiError(httpStatus.BAD_REQUEST, "Invalid verification code");
  }

  // Generate backup codes
  const backupCodes = generateBackupCodes(10);

  // Hash backup codes before storage
  const backupCodeRecords = await Promise.all(
    backupCodes.map(async (code) => ({
      codeHash: await bcrypt.hash(code, 12),
    }))
  );

  // Enable MFA and save backup codes
  const updatedMFA = await prisma.$transaction(async (tx) => {
    const updated = await tx.twoFactorAuth.update({
      where: { userId },
      data: {
        isEnabled: true,
        isVerified: true,
        enabledAt: new Date(),
      },
    });

    await tx.mFABackupCode.createMany({
      data: backupCodeRecords.map((bc) => ({
        mfaId: updated.id,
        ...bc,
      })),
    });

    // Update user MFA requirement
    await tx.user.update({
      where: { id: userId },
      data: { mfaRequired: true },
    });

    return updated;
  });

  // Log audit
  await logMFAAction(userId, "MFA_ENABLED", true, "");

  return {
    enabled: true,
    backupCodes, // Return once for user to save
  };
};

/**
 * Verify TOTP code during login
 */
const verifyMFACode = async (
  userId: string,
  token: string,
  ipAddress: string
): Promise<boolean> => {
  const mfa = await prisma.twoFactorAuth.findUnique({
    where: { userId },
  });

  if (!mfa || !mfa.isEnabled) {
    throw new ApiError(httpStatus.BAD_REQUEST, "MFA not enabled");
  }

  // Check if it's a backup code
  if (token.length > 6) {
    return await verifyBackupCode(userId, token, ipAddress);
  }

  // Decrypt secret
  const decryptedSecret = decryptData(mfa.secret, mfa.secretIV);

  // Verify TOTP code
  const verified = speakeasy.totp.verify({
    secret: decryptedSecret,
    encoding: "base32",
    token,
    window: 1,
  });

  if (verified) {
    // Update last used timestamp
    await prisma.twoFactorAuth.update({
      where: { userId },
      data: { lastUsedAt: new Date() },
    });

    await logMFAAction(userId, "MFA_VERIFIED", true, ipAddress);
  } else {
    await logMFAAction(userId, "MFA_FAILED", false, ipAddress);
  }

  return verified;
};

/**
 * Verify backup code
 */
const verifyBackupCode = async (
  userId: string,
  code: string,
  ipAddress: string
): Promise<boolean> => {
  const mfa = await prisma.twoFactorAuth.findUnique({
    where: { userId },
    include: {
      backupCodes: {
        where: { isUsed: false },
      },
    },
  });

  if (!mfa) {
    throw new ApiError(httpStatus.NOT_FOUND, "MFA not found");
  }

  // Check each unused backup code
  for (const backupCode of mfa.backupCodes) {
    const match = await bcrypt.compare(code, backupCode.codeHash);

    if (match) {
      // Mark as used
      await prisma.mFABackupCode.update({
        where: { id: backupCode.id },
        data: {
          isUsed: true,
          usedAt: new Date(),
          usedIP: ipAddress,
        },
      });

      await logMFAAction(userId, "BACKUP_CODE_USED", true, ipAddress);
      return true;
    }
  }

  await logMFAAction(userId, "MFA_FAILED", false, ipAddress);
  return false;
};

/**
 * Disable MFA
 */
const disableMFA = async (userId: string, password: string) => {
  // Verify password before disabling
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { password: true, role: true },
  });

  if (!user) {
    throw new ApiError(httpStatus.NOT_FOUND, "User not found");
  }

  const isPasswordValid = await bcrypt.compare(password, user.password);
  if (!isPasswordValid) {
    throw new ApiError(httpStatus.UNAUTHORIZED, "Invalid password");
  }

  // Don't allow disabling if mandatory for role
  if (user.role === "ADMIN" || user.role === "DOCTOR") {
    throw new ApiError(
      httpStatus.FORBIDDEN,
      "MFA is mandatory for your role and cannot be disabled"
    );
  }

  await prisma.$transaction([
    prisma.twoFactorAuth.update({
      where: { userId },
      data: { isEnabled: false },
    }),
    prisma.mFABackupCode.deleteMany({
      where: {
        mfa: { userId },
      },
    }),
  ]);

  await logMFAAction(userId, "MFA_DISABLED", true, "");
};

/**
 * Regenerate backup codes
 */
const regenerateBackupCodes = async (userId: string) => {
  const mfa = await prisma.twoFactorAuth.findUnique({
    where: { userId },
  });

  if (!mfa || !mfa.isEnabled) {
    throw new ApiError(httpStatus.BAD_REQUEST, "MFA not enabled");
  }

  // Generate new codes
  const backupCodes = generateBackupCodes(10);
  const backupCodeRecords = await Promise.all(
    backupCodes.map(async (code) => ({
      codeHash: await bcrypt.hash(code, 12),
    }))
  );

  await prisma.$transaction(async (tx) => {
    // Delete old codes
    await tx.mFABackupCode.deleteMany({
      where: { mfaId: mfa.id },
    });

    // Create new codes
    await tx.mFABackupCode.createMany({
      data: backupCodeRecords.map((bc) => ({
        mfaId: mfa.id,
        ...bc,
      })),
    });
  });

  await logMFAAction(userId, "BACKUP_CODE_REGENERATED", true, "");

  return backupCodes;
};

/**
 * Trust device
 */
const trustDevice = async (
  userId: string,
  deviceInfo: { userAgent: string; ipAddress: string }
) => {
  const deviceId = generateDeviceId(
    userId,
    deviceInfo.userAgent,
    deviceInfo.ipAddress
  );
  const deviceName = parseDeviceName(deviceInfo.userAgent);

  const expiresAt = new Date();
  expiresAt.setDate(expiresAt.getDate() + 30); // 30 days

  const device = await prisma.trustedDevice.upsert({
    where: { deviceId },
    create: {
      userId,
      deviceId,
      deviceName,
      ipAddress: deviceInfo.ipAddress,
      expiresAt,
    },
    update: {
      lastUsedAt: new Date(),
    },
  });

  await logMFAAction(userId, "DEVICE_TRUSTED", true, deviceInfo.ipAddress);

  return device;
};

/**
 * Check if device is trusted
 */
const isDeviceTrusted = async (
  userId: string,
  deviceInfo: { userAgent: string; ipAddress: string }
): Promise<boolean> => {
  const deviceId = generateDeviceId(
    userId,
    deviceInfo.userAgent,
    deviceInfo.ipAddress
  );

  const device = await prisma.trustedDevice.findFirst({
    where: {
      userId,
      deviceId,
      expiresAt: {
        gt: new Date(),
      },
    },
  });

  return !!device;
};

/**
 * Get MFA status
 */
const getMFAStatus = async (userId: string) => {
  const mfa = await prisma.twoFactorAuth.findUnique({
    where: { userId },
    include: {
      backupCodes: {
        where: { isUsed: false },
        select: { id: true },
      },
    },
  });

  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true, mfaRequired: true },
  });

  return {
    isEnabled: mfa?.isEnabled || false,
    isRequired: user?.mfaRequired || false,
    isMandatory: user?.role === "ADMIN" || user?.role === "DOCTOR",
    unusedBackupCodes: mfa?.backupCodes.length || 0,
    enabledAt: mfa?.enabledAt,
  };
};

// ============ Helper Functions ============

function generateBackupCodes(count: number = 10): string[] {
  const codes: string[] = [];

  for (let i = 0; i < count; i++) {
    // Generate 8-character alphanumeric code
    const code = crypto.randomBytes(4).toString("hex").toUpperCase();
    codes.push(code);
  }

  return codes;
}

function generateDeviceId(
  userId: string,
  userAgent: string,
  ipAddress: string
): string {
  const data = `${userId}-${userAgent}-${ipAddress}`;
  return crypto.createHash("sha256").update(data).digest("hex");
}

function parseDeviceName(userAgent: string): string {
  // Simple parsing - can be enhanced with user-agent parsing library
  if (userAgent.includes("Chrome")) return "Chrome Browser";
  if (userAgent.includes("Firefox")) return "Firefox Browser";
  if (userAgent.includes("Safari")) return "Safari Browser";
  if (userAgent.includes("Edge")) return "Edge Browser";
  return "Unknown Device";
}

async function logMFAAction(
  userId: string,
  action: string,
  success: boolean,
  ipAddress: string
) {
  await prisma.mFAAuditLog.create({
    data: {
      userId,
      action: action as any,
      success,
      ipAddress,
    },
  });
}

export const MFAService = {
  setupMFA,
  verifyAndEnableMFA,
  verifyMFACode,
  disableMFA,
  regenerateBackupCodes,
  trustDevice,
  isDeviceTrusted,
  getMFAStatus,
};
```

#### Step 2.2: Update Encryption Helper

**File**: `backend/src/helpers/encryption.ts`

```typescript
import crypto from "crypto";
import config from "../config";

const ALGORITHM = "aes-256-cbc";
const ENCRYPTION_KEY = Buffer.from(config.mfaEncryptionKey || "", "hex");

export function encryptData(text: string): { encrypted: string; iv: string } {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(ALGORITHM, ENCRYPTION_KEY, iv);

  let encrypted = cipher.update(text, "utf8", "hex");
  encrypted += cipher.final("hex");

  return {
    encrypted,
    iv: iv.toString("hex"),
  };
}

export function decryptData(encrypted: string, ivHex: string): string {
  const iv = Buffer.from(ivHex, "hex");
  const decipher = crypto.createDecipheriv(ALGORITHM, ENCRYPTION_KEY, iv);

  let decrypted = decipher.update(encrypted, "hex", "utf8");
  decrypted += decipher.final("utf8");

  return decrypted;
}
```

#### Step 2.3: Create MFA Controller

**File**: `backend/src/app/modules/MFA/mfa.controller.ts`

```typescript
import { Request, Response } from "express";
import catchAsync from "../../../shared/catchAsync";
import sendResponse from "../../../shared/sendResponse";
import httpStatus from "http-status";
import { MFAService } from "./mfa.service";

const setupMFA = catchAsync(async (req: Request, res: Response) => {
  const userId = (req as any).user.userId;

  const result = await MFAService.setupMFA(userId);

  sendResponse(res, {
    statusCode: httpStatus.OK,
    success: true,
    message: "MFA setup initiated. Scan QR code with authenticator app.",
    data: result,
  });
});

const verifyAndEnable = catchAsync(async (req: Request, res: Response) => {
  const userId = (req as any).user.userId;
  const { token } = req.body;

  const result = await MFAService.verifyAndEnableMFA(userId, token);

  sendResponse(res, {
    statusCode: httpStatus.OK,
    success: true,
    message: "MFA enabled successfully. Save your backup codes!",
    data: result,
  });
});

const disable = catchAsync(async (req: Request, res: Response) => {
  const userId = (req as any).user.userId;
  const { password } = req.body;

  await MFAService.disableMFA(userId, password);

  sendResponse(res, {
    statusCode: httpStatus.OK,
    success: true,
    message: "MFA disabled successfully",
  });
});

const regenerateBackupCodes = catchAsync(
  async (req: Request, res: Response) => {
    const userId = (req as any).user.userId;

    const codes = await MFAService.regenerateBackupCodes(userId);

    sendResponse(res, {
      statusCode: httpStatus.OK,
      success: true,
      message: "Backup codes regenerated. Save them securely!",
      data: { backupCodes: codes },
    });
  }
);

const getStatus = catchAsync(async (req: Request, res: Response) => {
  const userId = (req as any).user.userId;

  const status = await MFAService.getMFAStatus(userId);

  sendResponse(res, {
    statusCode: httpStatus.OK,
    success: true,
    message: "MFA status retrieved",
    data: status,
  });
});

export const MFAController = {
  setupMFA,
  verifyAndEnable,
  disable,
  regenerateBackupCodes,
  getStatus,
};
```

#### Step 2.4: Create MFA Routes

**File**: `backend/src/app/modules/MFA/mfa.routes.ts`

```typescript
import express from "express";
import { MFAController } from "./mfa.controller";
import auth from "../../middlewares/auth";
import validateRequest from "../../middlewares/validateRequest";
import { MFAValidation } from "./mfa.validation";
import { UserRole } from "@prisma/client";

const router = express.Router();

router.get(
  "/status",
  auth(UserRole.PATIENT, UserRole.DOCTOR, UserRole.ADMIN),
  MFAController.getStatus
);

router.post(
  "/setup",
  auth(UserRole.PATIENT, UserRole.DOCTOR, UserRole.ADMIN),
  MFAController.setupMFA
);

router.post(
  "/verify",
  auth(UserRole.PATIENT, UserRole.DOCTOR, UserRole.ADMIN),
  validateRequest(MFAValidation.verify),
  MFAController.verifyAndEnable
);

router.post(
  "/disable",
  auth(UserRole.PATIENT, UserRole.DOCTOR, UserRole.ADMIN),
  validateRequest(MFAValidation.disable),
  MFAController.disable
);

router.post(
  "/regenerate-backup-codes",
  auth(UserRole.PATIENT, UserRole.DOCTOR, UserRole.ADMIN),
  MFAController.regenerateBackupCodes
);

export const MFARoutes = router;
```

#### Step 2.5: Update Auth Service for MFA Login

**File**: `backend/src/app/modules/Auth/auth.service.ts`

```typescript
import { MFAService } from "../MFA/mfa.service";

const loginUser = async (
  payload: { email: string; password: string },
  req: any
) => {
  // ... existing password validation ...

  // Check if MFA is enabled
  const mfaStatus = await MFAService.getMFAStatus(userData.id);

  if (mfaStatus.isEnabled) {
    // Return temporary token that requires MFA
    const tempToken = jwtHelpers.generateToken(
      {
        userId: userData.id,
        role: userData.role,
        requiresMFA: true,
      },
      config.jwt.secret as Secret,
      "10m" // Short expiry for MFA challenge
    );

    return {
      requiresMFA: true,
      tempToken,
      // Don't return full access token yet
    };
  }

  // Normal login without MFA
  const accessToken = jwtHelpers.generateToken(/*...*/);
  const refreshToken = jwtHelpers.generateToken(/*...*/);

  return {
    accessToken,
    refreshToken,
    needPasswordChange: userData.needPasswordChange,
  };
};

const verifyMFALogin = async (tempToken: string, mfaCode: string, req: any) => {
  // Verify temp token
  const decoded = jwtHelpers.verifyToken(
    tempToken,
    config.jwt.secret as Secret
  );

  if (!decoded.requiresMFA) {
    throw new ApiError(httpStatus.BAD_REQUEST, "Invalid MFA flow");
  }

  // Verify MFA code
  const ipAddress = req.ip || "";
  const verified = await MFAService.verifyMFACode(
    decoded.userId,
    mfaCode,
    ipAddress
  );

  if (!verified) {
    throw new ApiError(httpStatus.UNAUTHORIZED, "Invalid MFA code");
  }

  // Generate real tokens
  const accessToken = jwtHelpers.generateToken(/*...*/);
  const refreshToken = jwtHelpers.generateToken(/*...*/);

  return {
    accessToken,
    refreshToken,
  };
};

export const AuthService = {
  // ... existing methods
  verifyMFALogin,
};
```

---

### Phase 3: Frontend Implementation

(Due to length, I'll provide the key components)

**File**: `frontend/src/components/mfa/MFASetup.tsx`

```tsx
"use client";

import { useState } from "react";
import { QRCodeSVG } from "qrcode.react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

export function MFASetupModal({ onClose }: { onClose: () => void }) {
  const [step, setStep] = useState<"qr" | "verify" | "backup">("qr");
  const [qrCode, setQRCode] = useState("");
  const [secret, setSecret] = useState("");
  const [verificationCode, setVerificationCode] = useState("");
  const [backupCodes, setBackupCodes] = useState<string[]>([]);

  const handleSetup = async () => {
    const res = await fetch("/api/mfa/setup", {
      headers: { Authorization: `Bearer ${token}` },
    });
    const data = await res.json();
    setQRCode(data.data.qrCode);
    setSecret(data.data.secret);
  };

  const handleVerify = async () => {
    const res = await fetch("/api/mfa/verify", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ token: verificationCode }),
    });

    const data = await res.json();
    setBackupCodes(data.data.backupCodes);
    setStep("backup");
  };

  return (
    <div className="p-6">
      {step === "qr" && (
        <div className="text-center">
          <h2 className="text-2xl font-bold mb-4">
            Enable Two-Factor Authentication
          </h2>
          <p className="mb-4">
            Scan this QR code with Google Authenticator or Authy
          </p>
          <QRCodeSVG value={qrCode} size={256} className="mx-auto mb-4" />
          <p className="text-sm text-gray-600 mb-4">
            Manual entry key: <code>{secret}</code>
          </p>
          <Button onClick={() => setStep("verify")}>Next: Verify Code</Button>
        </div>
      )}

      {step === "verify" && (
        <div>
          <h2 className="text-2xl font-bold mb-4">Verify Your Setup</h2>
          <p className="mb-4">
            Enter the 6-digit code from your authenticator app
          </p>
          <Input
            value={verificationCode}
            onChange={(e) => setVerificationCode(e.target.value)}
            placeholder="000000"
            maxLength={6}
            className="text-center text-2xl tracking-widest"
          />
          <Button onClick={handleVerify} className="mt-4 w-full">
            Verify & Enable MFA
          </Button>
        </div>
      )}

      {step === "backup" && (
        <div>
          <h2 className="text-2xl font-bold mb-4">Save Your Backup Codes</h2>
          <p className="mb-4 text-red-600 font-semibold">
            ‚ö†Ô∏è Save these codes! They are shown only once.
          </p>
          <div className="grid grid-cols-2 gap-2 mb-4 font-mono">
            {backupCodes.map((code, i) => (
              <div key={i} className="p-2 bg-gray-100 rounded">
                {code}
              </div>
            ))}
          </div>
          <Button
            onClick={() => {
              // Download as text file
              const blob = new Blob([backupCodes.join("\n")], {
                type: "text/plain",
              });
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = "mfa-backup-codes.txt";
              a.click();
            }}
          >
            Download Backup Codes
          </Button>
          <Button onClick={onClose} variant="outline" className="ml-2">
            Done
          </Button>
        </div>
      )}
    </div>
  );
}
```

---

## ‚úÖ Testing Checklist

### Functional Tests

- [ ] QR code generation works
- [ ] Google Authenticator can scan QR
- [ ] 6-digit code verification successful
- [ ] Backup codes generated (10 codes)
- [ ] Backup codes work for login
- [ ] Used backup codes marked as used
- [ ] MFA login flow works end-to-end
- [ ] "Trust this device" works for 30 days
- [ ] MFA required for doctors/admins
- [ ] Patients can enable/disable MFA

### Security Tests

- [ ] TOTP secrets encrypted in database
- [ ] Backup codes hashed (not plain text)
- [ ] Rate limiting on MFA attempts
- [ ] Audit log records all MFA events
- [ ] Cannot bypass MFA with old token
- [ ] Time window tolerance (¬±30s) works

---

## üéØ Acceptance Criteria

1. ‚úÖ TOTP MFA working with Google Authenticator
2. ‚úÖ QR code generation and secret storage encrypted
3. ‚úÖ 10 backup codes generated and hashed
4. ‚úÖ MFA mandatory for doctors/admins
5. ‚úÖ "Trust device" for 30 days functional
6. ‚úÖ Audit logging for all MFA actions
7. ‚úÖ Account recovery via backup codes
8. ‚úÖ Rate limiting prevents brute force
9. ‚úÖ UI/UX smooth and user-friendly
10. ‚úÖ No security vulnerabilities

---

**Task Status**: üìù Ready for implementation  
**Estimated Completion**: 1 week  
**Security Impact**: üîí Significantly improves account security

---

_Implementing MFA reduces account takeover risk by 99.9%. This is critical for healthcare applications handling sensitive data!_ üîê
