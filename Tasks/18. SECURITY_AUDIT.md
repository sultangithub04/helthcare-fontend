# Security Audit & Enhancement Guide

## ðŸ” Comprehensive Security Analysis

This document provides a detailed security audit of the PH-HealthCare application, identifying vulnerabilities and providing actionable remediation steps.

---

## ðŸŽ¯ Security Assessment Summary

### Risk Level Classification

- ðŸ”´ **CRITICAL**: Immediate action required (potential data breach)
- ðŸŸ  **HIGH**: Fix within 1 week (significant security risk)
- ðŸŸ¡ **MEDIUM**: Fix within 1 month (moderate risk)
- ðŸŸ¢ **LOW**: Fix when convenient (minor improvement)

---

## 1. Authentication & Authorization Vulnerabilities

### ðŸ”´ CRITICAL Issues

#### 1.1 Missing Account Lockout Mechanism

**Current State**: Unlimited login attempts allowed (only basic rate limiting)

**Vulnerability**:

- Brute force attacks possible
- Password guessing not effectively prevented
- Rate limit (5 attempts/15 min) too generous

**Remediation**:

```typescript
// NEEDED: backend/src/app/modules/Auth/auth.service.ts

model LoginAttempt {
  id         String   @id @default(uuid())
  email      String
  ipAddress  String
  userAgent  String
  success    Boolean
  attemptAt  DateTime @default(now())

  @@index([email, attemptAt])
  @@map("login_attempts")
}

// Service logic
const MAX_FAILED_ATTEMPTS = 5;
const LOCKOUT_DURATION_MINUTES = 30;

const loginUser = async (payload: { email: string; password: string }, ipAddress: string) => {
  // Check if account is locked
  const recentAttempts = await prisma.loginAttempt.findMany({
    where: {
      email: payload.email,
      attemptAt: {
        gte: new Date(Date.now() - LOCKOUT_DURATION_MINUTES * 60 * 1000)
      }
    },
    orderBy: { attemptAt: 'desc' }
  });

  const failedAttempts = recentAttempts.filter(a => !a.success);

  if (failedAttempts.length >= MAX_FAILED_ATTEMPTS) {
    // Account is locked
    const lockoutEndsAt = new Date(
      failedAttempts[0].attemptAt.getTime() + LOCKOUT_DURATION_MINUTES * 60 * 1000
    );

    throw new ApiError(
      httpStatus.FORBIDDEN,
      `Account locked due to too many failed attempts. Try again after ${lockoutEndsAt.toLocaleString()}`
    );
  }

  // ... existing login logic ...

  // Log attempt
  await prisma.loginAttempt.create({
    data: {
      email: payload.email,
      ipAddress,
      userAgent: req.headers['user-agent'] || 'unknown',
      success: isCorrectPassword
    }
  });

  // If successful, clear failed attempts
  if (isCorrectPassword) {
    await prisma.loginAttempt.deleteMany({
      where: {
        email: payload.email,
        success: false
      }
    });
  }

  return { accessToken, refreshToken };
};
```

#### 1.2 No Token Blacklisting (Refresh Tokens Never Invalidated)

**Current State**: Refresh tokens valid until expiry, can't revoke sessions

**Vulnerability**:

- Stolen refresh tokens work indefinitely
- No way to force logout user from all devices
- Compromised tokens can't be revoked

**Remediation**:

```prisma
model TokenBlacklist {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  reason    String?  // 'logout', 'password_changed', 'admin_revoked'
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@map("token_blacklist")
}

model ActiveSession {
  id           String   @id @default(uuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id])
  refreshToken String   @unique
  deviceInfo   String
  ipAddress    String
  lastActivity DateTime @default(now())
  expiresAt    DateTime
  createdAt    DateTime @default(now())

  @@index([userId])
  @@index([refreshToken])
  @@map("active_sessions")
}
```

```typescript
// Check blacklist before issuing tokens
const refreshToken = async (token: string) => {
  // Check if token is blacklisted
  const isBlacklisted = await prisma.tokenBlacklist.findUnique({
    where: { token },
  });

  if (isBlacklisted) {
    throw new ApiError(httpStatus.UNAUTHORIZED, "Token has been revoked");
  }

  // ... rest of refresh logic
};

// Logout - add to blacklist
const logout = async (token: string) => {
  const decoded = jwtHelpers.verifyToken(
    token,
    config.jwt.refresh_token_secret
  );

  await prisma.tokenBlacklist.create({
    data: {
      token,
      userId: decoded.userId,
      reason: "logout",
      expiresAt: new Date(decoded.exp * 1000),
    },
  });
};

// Logout from all devices
const logoutAllDevices = async (userId: string) => {
  const sessions = await prisma.activeSession.findMany({
    where: { userId },
  });

  await prisma.tokenBlacklist.createMany({
    data: sessions.map((session) => ({
      token: session.refreshToken,
      userId,
      reason: "logout_all_devices",
      expiresAt: session.expiresAt,
    })),
  });

  await prisma.activeSession.deleteMany({
    where: { userId },
  });
};
```

---

### ðŸŸ  HIGH Priority Issues

#### 1.3 Weak Password Policy

**Current State**: No password complexity requirements

**Vulnerability**:

- Users can set weak passwords ("123456", "password")
- No minimum complexity requirements

**Remediation**:

```typescript
import { z } from "zod";

const passwordSchema = z
  .string()
  .min(8, "Password must be at least 8 characters")
  .regex(/[A-Z]/, "Password must contain at least one uppercase letter")
  .regex(/[a-z]/, "Password must contain at least one lowercase letter")
  .regex(/[0-9]/, "Password must contain at least one number")
  .regex(
    /[^A-Za-z0-9]/,
    "Password must contain at least one special character"
  );

// Additionally, check against common passwords
const COMMON_PASSWORDS = [
  "123456",
  "password",
  "123456789",
  "12345678",
  "12345",
  "1234567",
  "qwerty",
  "abc123",
  "password123",
  "admin",
];

const validatePassword = (password: string) => {
  if (COMMON_PASSWORDS.includes(password.toLowerCase())) {
    throw new Error(
      "This password is too common. Please choose a stronger password."
    );
  }

  passwordSchema.parse(password);
};
```

#### 1.4 No Multi-Factor Authentication (MFA)

**Current State**: Single-factor authentication only

**Vulnerability**:

- Compromised passwords = full account access
- No second layer of defense

**Remediation**:

```prisma
model TwoFactorAuth {
  id        String   @id @default(uuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id])
  secret    String   // Encrypted TOTP secret
  enabled   Boolean  @default(false)
  backupCodes String[] // Encrypted backup codes
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("two_factor_auth")
}
```

```typescript
import speakeasy from "speakeasy";
import QRCode from "qrcode";

const setupMFA = async (userId: string) => {
  const secret = speakeasy.generateSecret({
    name: `PH-HealthCare (${user.email})`,
  });

  // Generate backup codes
  const backupCodes = Array.from({ length: 10 }, () =>
    Math.random().toString(36).substring(2, 10).toUpperCase()
  );

  await prisma.twoFactorAuth.create({
    data: {
      userId,
      secret: encrypt(secret.base32),
      backupCodes: backupCodes.map((code) => encrypt(code)),
      enabled: false,
    },
  });

  const qrCode = await QRCode.toDataURL(secret.otpauth_url);

  return {
    secret: secret.base32,
    qrCode,
    backupCodes,
  };
};

const verifyMFA = async (userId: string, token: string) => {
  const mfaData = await prisma.twoFactorAuth.findUnique({
    where: { userId },
  });

  if (!mfaData) throw new Error("MFA not set up");

  const secret = decrypt(mfaData.secret);
  const verified = speakeasy.totp.verify({
    secret,
    encoding: "base32",
    token,
    window: 2, // Allow 2 time steps before/after
  });

  return verified;
};
```

---

## 2. Input Validation & Sanitization

### ðŸŸ  HIGH Priority

#### 2.1 SQL Injection (Mitigated by Prisma, but...)

**Current State**: Using Prisma ORM (good), but raw queries exist

**Vulnerability**:

```typescript
// DANGEROUS if exists:
const result =
  await prisma.$queryRaw`SELECT * FROM users WHERE email = '${email}'`;
```

**Remediation**:

```typescript
// SAFE: Use parameterized queries
const result =
  await prisma.$queryRaw`SELECT * FROM users WHERE email = ${email}`;

// BETTER: Use Prisma's query builder
const result = await prisma.user.findUnique({
  where: { email },
});
```

#### 2.2 XSS (Cross-Site Scripting)

**Current State**: User inputs not sanitized on frontend

**Vulnerability**:

- Doctor names, patient names, review comments could contain malicious scripts
- `<script>alert('XSS')</script>` in review comment

**Remediation**:

```typescript
// Backend: Sanitize all user inputs
import DOMPurify from "isomorphic-dompurify";

const sanitizeInput = (input: string): string => {
  return DOMPurify.sanitize(input, {
    ALLOWED_TAGS: [], // No HTML tags allowed
    ALLOWED_ATTR: [],
  });
};

// Apply to all text inputs
const createReview = async (payload: any) => {
  const sanitizedPayload = {
    ...payload,
    comment: sanitizeInput(payload.comment),
  };

  // ... rest of logic
};
```

```tsx
// Frontend: Use Text Content (React automatically escapes)
// SAFE (React escapes by default):
<p>{review.comment}</p>

// DANGEROUS:
<p dangerouslySetInnerHTML={{ __html: review.comment }} />
```

#### 2.3 File Upload Validation

**Current State**: Weak file type validation

**Vulnerability**:

- Executable files could be uploaded disguised as images
- No virus scanning
- No file size limits enforced

**Remediation**:

```typescript
import { FileFilterCallback } from "multer";
import path from "path";

const ALLOWED_MIME_TYPES = [
  "image/jpeg",
  "image/jpg",
  "image/png",
  "image/webp",
  "application/pdf",
];

const ALLOWED_EXTENSIONS = [".jpg", ".jpeg", ".png", ".webp", ".pdf"];
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

const fileFilter: FileFilterCallback = (req, file, cb) => {
  // Check MIME type
  if (!ALLOWED_MIME_TYPES.includes(file.mimetype)) {
    return cb(new Error("Invalid file type. Only images and PDFs allowed."));
  }

  // Check file extension
  const ext = path.extname(file.originalname).toLowerCase();
  if (!ALLOWED_EXTENSIONS.includes(ext)) {
    return cb(new Error("Invalid file extension"));
  }

  // Check magic bytes (actual file content)
  // This prevents disguised executables
  const magicBytes = {
    "image/jpeg": [0xff, 0xd8, 0xff],
    "image/png": [0x89, 0x50, 0x4e, 0x47],
    "application/pdf": [0x25, 0x50, 0x44, 0x46],
  };

  // Verify file starts with correct magic bytes
  // Implementation needed...

  cb(null, true);
};

const upload = multer({
  fileFilter,
  limits: {
    fileSize: MAX_FILE_SIZE,
  },
});
```

---

## 3. Payment Security

### ðŸ”´ CRITICAL

#### 3.1 No Idempotency Check Before Webhook

**Current State**: Webhook processing could be duplicated

**Fix**: âœ… Already implemented with `stripeEventId` - Good!

#### 3.2 Missing Webhook Signature Verification

**Current State**: Webhook events not verified

**Vulnerability**:

- Attackers could send fake payment success webhooks
- Appointments marked as paid without actual payment

**Remediation**:

```typescript
// CRITICAL: Verify Stripe webhook signature
import Stripe from "stripe";

const handleStripeWebhookEvent = async (req: Request, res: Response) => {
  const sig = req.headers["stripe-signature"];
  const webhookSecret = config.stripeWebhookSecret;

  let event: Stripe.Event;

  try {
    // âœ… VERIFY SIGNATURE
    event = stripe.webhooks.constructEvent(
      req.body, // Raw body (not JSON parsed)
      sig as string,
      webhookSecret
    );
  } catch (err) {
    console.error("âš ï¸ Webhook signature verification failed:", err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  // Now process verified event
  await PaymentService.handleStripeWebhookEvent(event);

  res.json({ received: true });
};
```

---

## 4. API Security

### ðŸŸ¡ MEDIUM Priority

#### 4.1 Missing API Rate Limiting Headers

**Current State**: Rate limits applied but not exposed to clients

**Remediation**:

```typescript
// Add rate limit info to response headers
export const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  standardHeaders: true, // âœ… Already set
  legacyHeaders: false, // âœ… Already set
  handler: (req, res) => {
    res.status(429).json({
      success: false,
      message: "Too many requests. Please try again later.",
      retryAfter: Math.ceil(req.rateLimit.resetTime / 1000),
    });
  },
});
```

#### 4.2 CORS Misconfiguration

**Current State**: Hardcoded origins

**Vulnerability**:

- Production URLs not configurable
- Development origins exposed in production

**Remediation**:

```typescript
// backend/src/app.ts
const allowedOrigins =
  process.env.NODE_ENV === "production"
    ? [process.env.FRONTEND_URL, process.env.ADMIN_URL].filter(Boolean)
    : ["http://localhost:3000", "http://localhost:3001"];

app.use(
  cors({
    origin: (origin, callback) => {
      // Allow requests with no origin (mobile apps, Postman)
      if (!origin) return callback(null, true);

      if (allowedOrigins.indexOf(origin) !== -1) {
        callback(null, true);
      } else {
        callback(new Error("Not allowed by CORS"));
      }
    },
    credentials: true,
    methods: ["GET", "POST", "PUT", "PATCH", "DELETE"],
    allowedHeaders: ["Content-Type", "Authorization"],
  })
);
```

#### 4.3 Missing Request ID Tracing

**Current State**: Can't trace requests across systems

**Remediation**:

```typescript
import { v4 as uuidv4 } from "uuid";

app.use((req, res, next) => {
  req.id = req.headers["x-request-id"] || uuidv4();
  res.setHeader("X-Request-ID", req.id);
  next();
});
```

---

## 5. Data Privacy & Compliance

### ðŸŸ  HIGH Priority

#### 5.1 No Data Encryption at Rest

**Current State**: Sensitive data stored in plaintext

**Vulnerability**:

- Database backup exposure = data breach
- SSN, medical records, phone numbers not encrypted

**Remediation**:

```typescript
import crypto from "crypto";

const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY; // 32 bytes
const ALGORITHM = "aes-256-gcm";

export const encrypt = (text: string): string => {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(
    ALGORITHM,
    Buffer.from(ENCRYPTION_KEY, "hex"),
    iv
  );

  let encrypted = cipher.update(text, "utf8", "hex");
  encrypted += cipher.final("hex");

  const authTag = cipher.getAuthTag();

  return `${iv.toString("hex")}:${authTag.toString("hex")}:${encrypted}`;
};

export const decrypt = (encrypted: string): string => {
  const [ivHex, authTagHex, encryptedHex] = encrypted.split(":");

  const decipher = crypto.createDecipheriv(
    ALGORITHM,
    Buffer.from(ENCRYPTION_KEY, "hex"),
    Buffer.from(ivHex, "hex")
  );

  decipher.setAuthTag(Buffer.from(authTagHex, "hex"));

  let decrypted = decipher.update(encryptedHex, "hex", "utf8");
  decrypted += decipher.final("utf8");

  return decrypted;
};

// Apply to sensitive fields
const createPatient = async (data: any) => {
  const encryptedData = {
    ...data,
    contactNumber: encrypt(data.contactNumber),
    address: encrypt(data.address),
  };

  return await prisma.patient.create({ data: encryptedData });
};
```

#### 5.2 Missing Audit Logs

**Current State**: No tracking of who changed what

**Remediation**:

```prisma
model AuditLog {
  id          String   @id @default(uuid())
  userId      String?
  user        User?    @relation(fields: [userId], references: [id])
  action      String   // CREATE, UPDATE, DELETE, LOGIN, LOGOUT
  entity      String   // User, Doctor, Appointment, etc.
  entityId    String?
  changes     Json?    // What changed
  ipAddress   String
  userAgent   String
  timestamp   DateTime @default(now())

  @@index([userId])
  @@index([entity, entityId])
  @@index([timestamp])
  @@map("audit_logs")
}
```

---

## ðŸŽ¯ Security Checklist

### Authentication

- [ ] Account lockout after failed attempts
- [ ] Token blacklisting/revocation
- [ ] Strong password policy
- [ ] MFA support
- [ ] Session management
- [ ] Suspicious login detection

### Authorization

- [ ] Role-based access control (RBAC) âœ…
- [ ] Resource-level permissions
- [ ] API endpoint protection âœ…
- [ ] Frontend route protection âœ…

### Data Protection

- [ ] Encryption at rest (sensitive fields)
- [ ] Encryption in transit (HTTPS) âœ…
- [ ] Input validation âœ… (Zod)
- [ ] Output encoding
- [ ] SQL injection prevention âœ… (Prisma)
- [ ] XSS prevention
- [ ] CSRF protection

### API Security

- [ ] Rate limiting âœ…
- [ ] CORS configuration
- [ ] Request validation âœ…
- [ ] Response headers (security)
- [ ] API versioning

### File Upload

- [ ] File type validation
- [ ] File size limits
- [ ] Virus scanning
- [ ] Secure storage

### Payment Security

- [ ] Webhook signature verification
- [ ] Idempotency âœ…
- [ ] PCI DSS compliance (Stripe handles)
- [ ] Refund protection

### Monitoring

- [ ] Audit logging
- [ ] Error tracking (Sentry)
- [ ] Security alerts
- [ ] Anomaly detection

---

## ðŸ“– Implementation Priority

**Week 1 (CRITICAL)**:

1. Webhook signature verification
2. Account lockout mechanism
3. Token blacklisting

**Week 2 (HIGH)**: 4. Password policy enforcement 5. XSS prevention 6. File upload security

**Week 3 (MEDIUM)**: 7. Data encryption at rest 8. Audit logging 9. MFA implementation

**Week 4 (LOW)**: 10. Security monitoring dashboard 11. Penetration testing 12. Security documentation

---

**Related Documents**:

- `TASK_11_TESTING.md` - Security testing procedures
- `HIPAA_COMPLIANCE.md` - Healthcare data regulations
