# Task 07: Backend Unit & Integration Testing Suite

## üìã Task Overview

**Difficulty**: üü° **INTERMEDIATE**  
**Estimated Time**: 1-2 weeks  
**Priority**: HIGH  
**Category**: Testing & Quality

### Objective

Implement a comprehensive testing suite for the backend using Jest and Supertest, covering unit tests for services, integration tests for API endpoints, database testing with test databases, mocking strategies, and achieving >80% code coverage to ensure code quality and prevent regressions.

### Learning Outcomes

- Master Jest testing framework for Node.js/TypeScript
- Write effective unit tests for business logic
- Implement integration tests for API endpoints
- Mock external dependencies (Stripe, Cloudinary, emails)
- Set up test databases with Prisma
- Measure and improve code coverage
- Implement test-driven development (TDD) practices
- Write maintainable and readable tests

---

## üéØ Requirements

### Functional Requirements

1. **Test Coverage Targets**
   | Component | Coverage Target | Priority |
   |-----------|----------------|----------|
   | Services (business logic) | >90% | üî¥ CRITICAL |
   | Controllers | >85% | üî¥ CRITICAL |
   | Middleware | >90% | üî¥ CRITICAL |
   | Utilities/Helpers | >95% | üü† HIGH |
   | Routes | >80% | üü† HIGH |
   | Overall Project | >80% | üî¥ CRITICAL |

2. **Test Types**

   - **Unit Tests**: Test individual functions/methods in isolation
   - **Integration Tests**: Test API endpoints with database
   - **Service Tests**: Test business logic with mocked dependencies
   - **Middleware Tests**: Test auth, validation, error handling
   - **Database Tests**: Test Prisma queries and transactions

3. **Testing Scenarios**
   - Happy path (successful operations)
   - Error handling (validation errors, not found, unauthorized)
   - Edge cases (empty data, boundary values)
   - Authentication/authorization
   - Database constraints and relationships
   - Transaction rollbacks
   - File uploads
   - External API failures

### Technical Requirements

1. **Technology Stack**

   - **Test Framework**: Jest v29
   - **HTTP Testing**: Supertest
   - **Mocking**: Jest mocks, jest-mock-extended
   - **Test Database**: PostgreSQL test instance
   - **Coverage**: Istanbul (built into Jest)
   - **TypeScript**: ts-jest

2. **Test Environment Setup**

   - Separate test database
   - Environment variables for testing
   - Database migrations before tests
   - Seed data for tests
   - Clean up after each test

3. **Performance Targets**
   - Test suite runs in <2 minutes
   - Parallel test execution
   - Fast database operations (transactions)
   - Minimal external API calls

---

## üèóÔ∏è Testing Architecture

### Test Structure

```
backend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ app/
‚îÇ       ‚îî‚îÄ‚îÄ modules/
‚îÇ           ‚îî‚îÄ‚îÄ Doctor/
‚îÇ               ‚îú‚îÄ‚îÄ doctor.service.ts
‚îÇ               ‚îú‚îÄ‚îÄ doctor.controller.ts
‚îÇ               ‚îú‚îÄ‚îÄ doctor.routes.ts
‚îÇ               ‚îî‚îÄ‚îÄ __tests__/
‚îÇ                   ‚îú‚îÄ‚îÄ doctor.service.test.ts    # Unit tests
‚îÇ                   ‚îú‚îÄ‚îÄ doctor.controller.test.ts # Controller tests
‚îÇ                   ‚îî‚îÄ‚îÄ doctor.integration.test.ts # API integration tests
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ setup.ts              # Global test setup
‚îÇ   ‚îú‚îÄ‚îÄ teardown.ts           # Global test teardown
‚îÇ   ‚îú‚îÄ‚îÄ helpers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ testDb.ts         # Test database utilities
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mockData.ts       # Test data factories
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authHelper.ts     # Authentication helpers
‚îÇ   ‚îî‚îÄ‚îÄ fixtures/
‚îÇ       ‚îú‚îÄ‚îÄ users.json        # Test user data
‚îÇ       ‚îî‚îÄ‚îÄ doctors.json      # Test doctor data
‚îú‚îÄ‚îÄ jest.config.js            # Jest configuration
‚îî‚îÄ‚îÄ jest.setup.js             # Jest setup file
```

### Test Database Strategy

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Development Database   ‚îÇ
‚îÇ  (Real data)            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Test Database          ‚îÇ
‚îÇ  (Isolated, clean)      ‚îÇ
‚îÇ                         ‚îÇ
‚îÇ  Before Each Test:      ‚îÇ
‚îÇ  1. Run migrations      ‚îÇ
‚îÇ  2. Seed test data      ‚îÇ
‚îÇ                         ‚îÇ
‚îÇ  After Each Test:       ‚îÇ
‚îÇ  1. Truncate tables     ‚îÇ
‚îÇ  2. Reset sequences     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìù Implementation Guide

### Phase 1: Test Environment Setup

#### Step 1.1: Install Testing Dependencies

```bash
cd backend
pnpm install -D jest @types/jest ts-jest supertest @types/supertest
pnpm install -D jest-mock-extended
```

#### Step 1.2: Configure Jest

**File**: `backend/jest.config.js`

```javascript
module.exports = {
  preset: "ts-jest",
  testEnvironment: "node",
  roots: ["<rootDir>/src"],
  testMatch: ["**/__tests__/**/*.test.ts", "**/?(*.)+(spec|test).ts"],
  transform: {
    "^.+\\.ts$": "ts-jest",
  },
  collectCoverageFrom: [
    "src/**/*.{ts,js}",
    "!src/**/*.d.ts",
    "!src/**/__tests__/**",
    "!src/server.ts",
    "!src/app.ts",
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  coverageDirectory: "coverage",
  coverageReporters: ["text", "lcov", "html"],
  setupFilesAfterEnv: ["<rootDir>/jest.setup.js"],
  globalSetup: "<rootDir>/tests/setup.ts",
  globalTeardown: "<rootDir>/tests/teardown.ts",
  moduleNameMapper: {
    "^@/(.*)$": "<rootDir>/src/$1",
  },
  testTimeout: 30000,
  maxWorkers: "50%", // Use half of available CPU cores
  verbose: true,
};
```

#### Step 1.3: Create Test Setup

**File**: `backend/jest.setup.js`

```javascript
// Extend Jest matchers
expect.extend({
  toBeWithinRange(received, floor, ceiling) {
    const pass = received >= floor && received <= ceiling;
    if (pass) {
      return {
        message: () =>
          `expected ${received} not to be within range ${floor} - ${ceiling}`,
        pass: true,
      };
    } else {
      return {
        message: () =>
          `expected ${received} to be within range ${floor} - ${ceiling}`,
        pass: false,
      };
    }
  },
});

// Set test environment variables
process.env.NODE_ENV = "test";
process.env.DATABASE_URL =
  process.env.TEST_DATABASE_URL ||
  "postgresql://test:test@localhost:5432/phhealth_test";
process.env.JWT_SECRET = "test-jwt-secret";
process.env.JWT_REFRESH_SECRET = "test-jwt-refresh-secret";
```

#### Step 1.4: Create Global Test Setup

**File**: `backend/tests/setup.ts`

```typescript
import { execSync } from "child_process";
import dotenv from "dotenv";

async function globalSetup() {
  // Load test environment variables
  dotenv.config({ path: ".env.test" });

  console.log("üß™ Setting up test environment...");

  try {
    // Run database migrations
    console.log("üì¶ Running database migrations...");
    execSync("npx prisma migrate deploy", {
      env: {
        ...process.env,
        DATABASE_URL: process.env.TEST_DATABASE_URL,
      },
      stdio: "inherit",
    });

    console.log("‚úÖ Test environment ready");
  } catch (error) {
    console.error("‚ùå Failed to setup test environment:", error);
    throw error;
  }
}

export default globalSetup;
```

**File**: `backend/tests/teardown.ts`

```typescript
async function globalTeardown() {
  console.log("üßπ Cleaning up test environment...");
  // Add any global cleanup here
}

export default globalTeardown;
```

#### Step 1.5: Create Test Database Utilities

**File**: `backend/tests/helpers/testDb.ts`

```typescript
import { PrismaClient } from "@prisma/client";
import { execSync } from "child_process";

const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.TEST_DATABASE_URL,
    },
  },
});

/**
 * Clean all tables in test database
 */
export async function cleanDatabase() {
  const tables = await prisma.$queryRaw<Array<{ tablename: string }>>`
    SELECT tablename FROM pg_tables WHERE schemaname='public'
  `;

  for (const { tablename } of tables) {
    if (tablename !== "_prisma_migrations") {
      try {
        await prisma.$executeRawUnsafe(
          `TRUNCATE TABLE "public"."${tablename}" CASCADE;`
        );
      } catch (error) {
        console.log(`Could not truncate ${tablename}`);
      }
    }
  }
}

/**
 * Reset database sequences
 */
export async function resetSequences() {
  const sequences = await prisma.$queryRaw<Array<{ sequencename: string }>>`
    SELECT sequencename FROM pg_sequences WHERE schemaname='public'
  `;

  for (const { sequencename } of sequences) {
    await prisma.$executeRawUnsafe(
      `ALTER SEQUENCE "public"."${sequencename}" RESTART WITH 1;`
    );
  }
}

/**
 * Setup test database before each test
 */
export async function setupTestDb() {
  await cleanDatabase();
  await resetSequences();
}

/**
 * Teardown test database after each test
 */
export async function teardownTestDb() {
  await cleanDatabase();
}

/**
 * Disconnect from test database
 */
export async function disconnectTestDb() {
  await prisma.$disconnect();
}

export { prisma as testPrisma };
```

#### Step 1.6: Create Test Data Factories

**File**: `backend/tests/helpers/mockData.ts`

```typescript
import bcrypt from "bcrypt";
import { UserRole, UserStatus, Gender } from "@prisma/client";

export const mockUsers = {
  admin: {
    email: "admin@test.com",
    password: bcrypt.hashSync("password123", 12),
    role: UserRole.ADMIN,
    status: UserStatus.ACTIVE,
    needPasswordChange: false,
  },
  doctor: {
    email: "doctor@test.com",
    password: bcrypt.hashSync("password123", 12),
    role: UserRole.DOCTOR,
    status: UserStatus.ACTIVE,
    needPasswordChange: false,
  },
  patient: {
    email: "patient@test.com",
    password: bcrypt.hashSync("password123", 12),
    role: UserRole.PATIENT,
    status: UserStatus.ACTIVE,
    needPasswordChange: false,
  },
};

export const mockDoctorData = {
  name: "Dr. John Smith",
  email: "doctor@test.com",
  profilePhoto: "https://example.com/photo.jpg",
  contactNumber: "1234567890",
  address: "123 Main St",
  registrationNumber: "REG123456",
  experience: 10,
  gender: Gender.MALE,
  appointmentFee: 500,
  qualification: "MBBS, MD",
  currentWorkingPlace: "City Hospital",
  designation: "Senior Consultant",
};

export const mockPatientData = {
  name: "Jane Doe",
  email: "patient@test.com",
  profilePhoto: "https://example.com/photo.jpg",
  contactNumber: "9876543210",
  address: "456 Oak Ave",
};

export const mockAppointmentData = {
  videoCallingId: "vc-123",
  status: "SCHEDULED" as const,
  paymentStatus: "PAID" as const,
};

/**
 * Create test user with role
 */
export function createMockUser(role: UserRole = UserRole.PATIENT) {
  return {
    id: `user-${role}-${Date.now()}`,
    email: `${role.toLowerCase()}@test.com`,
    password: bcrypt.hashSync("password123", 12),
    role,
    status: UserStatus.ACTIVE,
    needPasswordChange: false,
    isDeleted: false,
    createdAt: new Date(),
    updatedAt: new Date(),
  };
}

/**
 * Create test doctor
 */
export function createMockDoctor(overrides = {}) {
  return {
    id: `doctor-${Date.now()}`,
    ...mockDoctorData,
    averageRating: 4.5,
    isDeleted: false,
    createdAt: new Date(),
    updatedAt: new Date(),
    ...overrides,
  };
}

/**
 * Create test patient
 */
export function createMockPatient(overrides = {}) {
  return {
    id: `patient-${Date.now()}`,
    ...mockPatientData,
    isDeleted: false,
    createdAt: new Date(),
    updatedAt: new Date(),
    ...overrides,
  };
}
```

#### Step 1.7: Create Auth Test Helper

**File**: `backend/tests/helpers/authHelper.ts`

```typescript
import jwt from "jsonwebtoken";
import { UserRole } from "@prisma/client";

export function generateTestToken(userId: string, role: UserRole): string {
  return jwt.sign(
    { userId, role },
    process.env.JWT_SECRET || "test-jwt-secret",
    { expiresIn: "1h" }
  );
}

export function createAuthHeader(
  userId: string,
  role: UserRole
): { Authorization: string } {
  const token = generateTestToken(userId, role);
  return {
    Authorization: `Bearer ${token}`,
  };
}
```

#### Step 1.8: Update package.json Scripts

**File**: `backend/package.json`

```json
{
  "scripts": {
    "test": "jest --coverage",
    "test:watch": "jest --watch",
    "test:unit": "jest --testPathPattern='.test.ts$'",
    "test:integration": "jest --testPathPattern='.integration.test.ts$'",
    "test:coverage": "jest --coverage --coverageReporters=text-lcov | coveralls",
    "test:ci": "jest --ci --coverage --maxWorkers=2"
  }
}
```

---

### Phase 2: Writing Unit Tests

#### Step 2.1: Service Unit Tests Example

**File**: `backend/src/app/modules/Doctor/\__tests__/doctor.service.test.ts`

```typescript
import { DoctorService } from "../doctor.service";
import { testPrisma } from "../../../../tests/helpers/testDb";
import {
  createMockDoctor,
  createMockUser,
} from "../../../../tests/helpers/mockData";
import { UserRole } from "@prisma/client";

// Mock Prisma
jest.mock("../../../shared/prisma", () => ({
  __esModule: true,
  default: testPrisma,
}));

// Mock file uploader
jest.mock("../../../helpers/fileUploader", () => ({
  FileUploadHelper: {
    uploadToCloudinary: jest.fn().mockResolvedValue({
      secure_url: "https://cloudinary.com/test-image.jpg",
    }),
  },
}));

describe("DoctorService", () => {
  beforeEach(async () => {
    // Clean database before each test
    await testPrisma.doctor.deleteMany();
    await testPrisma.user.deleteMany();
  });

  afterAll(async () => {
    await testPrisma.$disconnect();
  });

  describe("getAllFromDB", () => {
    it("should return all active doctors", async () => {
      // Arrange
      const user = await testPrisma.user.create({
        data: createMockUser(UserRole.DOCTOR),
      });

      await testPrisma.doctor.create({
        data: {
          ...createMockDoctor(),
          email: user.email,
        },
      });

      // Act
      const result = await DoctorService.getAllFromDB({}, {});

      // Assert
      expect(result.data).toHaveLength(1);
      expect(result.data[0].email).toBe(user.email);
      expect(result.data[0].isDeleted).toBe(false);
    });

    it("should filter doctors by search term", async () => {
      // Arrange
      await testPrisma.doctor.create({
        data: createMockDoctor({ name: "Dr. John Smith" }),
      });

      await testPrisma.doctor.create({
        data: createMockDoctor({ name: "Dr. Sarah Johnson" }),
      });

      // Act
      const result = await DoctorService.getAllFromDB(
        { searchTerm: "John" },
        {}
      );

      // Assert
      expect(result.data).toHaveLength(1);
      expect(result.data[0].name).toContain("John");
    });

    it("should exclude deleted doctors", async () => {
      // Arrange
      await testPrisma.doctor.create({
        data: createMockDoctor({ isDeleted: true }),
      });

      // Act
      const result = await DoctorService.getAllFromDB({}, {});

      // Assert
      expect(result.data).toHaveLength(0);
    });

    it("should paginate results correctly", async () => {
      // Arrange - Create 15 doctors
      for (let i = 0; i < 15; i++) {
        await testPrisma.doctor.create({
          data: createMockDoctor({ email: `doctor${i}@test.com` }),
        });
      }

      // Act
      const result = await DoctorService.getAllFromDB(
        {},
        { page: 1, limit: 10 }
      );

      // Assert
      expect(result.data).toHaveLength(10);
      expect(result.meta.total).toBe(15);
      expect(result.meta.page).toBe(1);
      expect(result.meta.limit).toBe(10);
    });

    it("should sort doctors by rating descending", async () => {
      // Arrange
      await testPrisma.doctor.create({
        data: createMockDoctor({
          name: "Low Rating",
          averageRating: 3.0,
        }),
      });

      await testPrisma.doctor.create({
        data: createMockDoctor({
          name: "High Rating",
          averageRating: 4.8,
        }),
      });

      // Act
      const result = await DoctorService.getAllFromDB(
        {},
        { sortBy: "averageRating", sortOrder: "desc" }
      );

      // Assert
      expect(result.data[0].averageRating).toBeGreaterThan(
        result.data[1].averageRating
      );
    });
  });

  describe("getByIdFromDB", () => {
    it("should return doctor by ID", async () => {
      // Arrange
      const doctor = await testPrisma.doctor.create({
        data: createMockDoctor(),
      });

      // Act
      const result = await DoctorService.getByIdFromDB(doctor.id);

      // Assert
      expect(result).toBeDefined();
      expect(result?.id).toBe(doctor.id);
      expect(result?.email).toBe(doctor.email);
    });

    it("should return null for non-existent doctor", async () => {
      // Act
      const result = await DoctorService.getByIdFromDB("non-existent-id");

      // Assert
      expect(result).toBeNull();
    });

    it("should return null for deleted doctor", async () => {
      // Arrange
      const doctor = await testPrisma.doctor.create({
        data: createMockDoctor({ isDeleted: true }),
      });

      // Act
      const result = await DoctorService.getByIdFromDB(doctor.id);

      // Assert
      expect(result).toBeNull();
    });
  });

  describe("updateIntoDB", () => {
    it("should update doctor successfully", async () => {
      // Arrange
      const user = await testPrisma.user.create({
        data: createMockUser(UserRole.DOCTOR),
      });

      const doctor = await testPrisma.doctor.create({
        data: {
          ...createMockDoctor(),
          email: user.email,
        },
      });

      const updateData = {
        name: "Dr. Updated Name",
        appointmentFee: 600,
      };

      // Act
      const result = await DoctorService.updateIntoDB(doctor.id, updateData);

      // Assert
      expect(result.name).toBe("Dr. Updated Name");
      expect(result.appointmentFee).toBe(600);
    });

    it("should throw error when updating non-existent doctor", async () => {
      // Act & Assert
      await expect(
        DoctorService.updateIntoDB("non-existent-id", {})
      ).rejects.toThrow("Doctor not found");
    });

    it("should update specialties correctly", async () => {
      // Arrange
      const specialty = await testPrisma.specialties.create({
        data: {
          title: "Cardiology",
          icon: "heart.png",
        },
      });

      const doctor = await testPrisma.doctor.create({
        data: createMockDoctor(),
      });

      // Act
      const result = await DoctorService.updateIntoDB(doctor.id, {
        specialties: [specialty.id],
      });

      // Assert
      const updatedDoctor = await testPrisma.doctor.findUnique({
        where: { id: doctor.id },
        include: { doctorSpecialties: true },
      });

      expect(updatedDoctor?.doctorSpecialties).toHaveLength(1);
    });
  });

  describe("deleteFromDB", () => {
    it("should soft delete doctor and user", async () => {
      // Arrange
      const user = await testPrisma.user.create({
        data: createMockUser(UserRole.DOCTOR),
      });

      const doctor = await testPrisma.doctor.create({
        data: {
          ...createMockDoctor(),
          email: user.email,
        },
      });

      // Act
      await DoctorService.deleteFromDB(doctor.id);

      // Assert
      const deletedDoctor = await testPrisma.doctor.findUnique({
        where: { id: doctor.id },
      });

      const deletedUser = await testPrisma.user.findUnique({
        where: { id: user.id },
      });

      expect(deletedDoctor?.isDeleted).toBe(true);
      expect(deletedUser?.isDeleted).toBe(true);
    });

    it("should throw error when deleting non-existent doctor", async () => {
      // Act & Assert
      await expect(
        DoctorService.deleteFromDB("non-existent-id")
      ).rejects.toThrow("Doctor not found");
    });
  });
});
```

---

### Phase 3: Integration Tests

#### Step 3.1: API Integration Tests Example

**File**: `backend/src/app/modules/Doctor/__tests__/doctor.integration.test.ts`

```typescript
import request from "supertest";
import app from "../../../app";
import {
  testPrisma,
  setupTestDb,
  teardownTestDb,
} from "../../../../tests/helpers/testDb";
import { createAuthHeader } from "../../../../tests/helpers/authHelper";
import {
  createMockUser,
  createMockDoctor,
} from "../../../../tests/helpers/mockData";
import { UserRole } from "@prisma/client";

describe("Doctor API Integration Tests", () => {
  let adminToken: string;
  let doctorToken: string;
  let patientToken: string;

  beforeAll(async () => {
    await setupTestDb();

    // Create test users
    const admin = await testPrisma.user.create({
      data: createMockUser(UserRole.ADMIN),
    });

    const doctor = await testPrisma.user.create({
      data: createMockUser(UserRole.DOCTOR),
    });

    const patient = await testPrisma.user.create({
      data: createMockUser(UserRole.PATIENT),
    });

    adminToken = createAuthHeader(admin.id, admin.role).Authorization;
    doctorToken = createAuthHeader(doctor.id, doctor.role).Authorization;
    patientToken = createAuthHeader(patient.id, patient.role).Authorization;
  });

  afterAll(async () => {
    await teardownTestDb();
    await testPrisma.$disconnect();
  });

  describe("GET /api/v1/doctor", () => {
    beforeEach(async () => {
      await testPrisma.doctor.deleteMany();
    });

    it("should return 200 and list of doctors", async () => {
      // Arrange
      await testPrisma.doctor.create({
        data: createMockDoctor(),
      });

      // Act
      const response = await request(app).get("/api/v1/doctor").expect(200);

      // Assert
      expect(response.body.success).toBe(true);
      expect(response.body.data).toBeInstanceOf(Array);
      expect(response.body.data).toHaveLength(1);
    });

    it("should filter doctors by specialty", async () => {
      // Arrange
      const specialty = await testPrisma.specialties.create({
        data: {
          title: "Cardiology",
          icon: "heart.png",
        },
      });

      const doctor = await testPrisma.doctor.create({
        data: createMockDoctor(),
      });

      await testPrisma.doctorSpecialties.create({
        data: {
          doctorId: doctor.id,
          specialitiesId: specialty.id,
        },
      });

      // Act
      const response = await request(app)
        .get("/api/v1/doctor")
        .query({ specialties: specialty.id })
        .expect(200);

      // Assert
      expect(response.body.data).toHaveLength(1);
    });

    it("should return paginated results", async () => {
      // Arrange - Create 5 doctors
      for (let i = 0; i < 5; i++) {
        await testPrisma.doctor.create({
          data: createMockDoctor({ email: `doctor${i}@test.com` }),
        });
      }

      // Act
      const response = await request(app)
        .get("/api/v1/doctor")
        .query({ page: 1, limit: 3 })
        .expect(200);

      // Assert
      expect(response.body.data).toHaveLength(3);
      expect(response.body.meta.total).toBe(5);
      expect(response.body.meta.page).toBe(1);
    });
  });

  describe("GET /api/v1/doctor/:id", () => {
    it("should return 200 and doctor details", async () => {
      // Arrange
      const doctor = await testPrisma.doctor.create({
        data: createMockDoctor(),
      });

      // Act
      const response = await request(app)
        .get(`/api/v1/doctor/${doctor.id}`)
        .expect(200);

      // Assert
      expect(response.body.success).toBe(true);
      expect(response.body.data.id).toBe(doctor.id);
    });

    it("should return 404 for non-existent doctor", async () => {
      // Act
      const response = await request(app)
        .get("/api/v1/doctor/non-existent-id")
        .expect(404);

      // Assert
      expect(response.body.success).toBe(false);
    });
  });

  describe("PATCH /api/v1/doctor/:id", () => {
    it("should return 401 without authentication", async () => {
      // Act
      await request(app)
        .patch("/api/v1/doctor/some-id")
        .send({ name: "Updated Name" })
        .expect(401);
    });

    it("should return 403 for patient role", async () => {
      // Arrange
      const doctor = await testPrisma.doctor.create({
        data: createMockDoctor(),
      });

      // Act
      await request(app)
        .patch(`/api/v1/doctor/${doctor.id}`)
        .set("Authorization", patientToken)
        .send({ name: "Updated Name" })
        .expect(403);
    });

    it("should update doctor as admin", async () => {
      // Arrange
      const doctor = await testPrisma.doctor.create({
        data: createMockDoctor(),
      });

      // Act
      const response = await request(app)
        .patch(`/api/v1/doctor/${doctor.id}`)
        .set("Authorization", adminToken)
        .send({
          name: "Dr. Updated Name",
          appointmentFee: 700,
        })
        .expect(200);

      // Assert
      expect(response.body.success).toBe(true);
      expect(response.body.data.name).toBe("Dr. Updated Name");
      expect(response.body.data.appointmentFee).toBe(700);
    });

    it("should return 400 for invalid data", async () => {
      // Arrange
      const doctor = await testPrisma.doctor.create({
        data: createMockDoctor(),
      });

      // Act
      const response = await request(app)
        .patch(`/api/v1/doctor/${doctor.id}`)
        .set("Authorization", adminToken)
        .send({
          appointmentFee: -100, // Invalid negative fee
        })
        .expect(400);

      // Assert
      expect(response.body.success).toBe(false);
    });
  });

  describe("DELETE /api/v1/doctor/:id", () => {
    it("should soft delete doctor as admin", async () => {
      // Arrange
      const user = await testPrisma.user.create({
        data: createMockUser(UserRole.DOCTOR),
      });

      const doctor = await testPrisma.doctor.create({
        data: {
          ...createMockDoctor(),
          email: user.email,
        },
      });

      // Act
      await request(app)
        .delete(`/api/v1/doctor/${doctor.id}`)
        .set("Authorization", adminToken)
        .expect(200);

      // Assert
      const deletedDoctor = await testPrisma.doctor.findUnique({
        where: { id: doctor.id },
      });

      expect(deletedDoctor?.isDeleted).toBe(true);
    });
  });
});
```

---

### Phase 4: Middleware Tests

**File**: `backend/src/app/middlewares/__tests__/auth.test.ts`

```typescript
import { Request, Response, NextFunction } from "express";
import auth from "../auth";
import { UserRole } from "@prisma/client";
import { generateTestToken } from "../../../tests/helpers/authHelper";

describe("Auth Middleware", () => {
  let mockRequest: Partial<Request>;
  let mockResponse: Partial<Response>;
  let nextFunction: NextFunction;

  beforeEach(() => {
    mockRequest = {
      headers: {},
    };
    mockResponse = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    nextFunction = jest.fn();
  });

  it("should call next() with valid token", () => {
    // Arrange
    const token = generateTestToken("user-123", UserRole.ADMIN);
    mockRequest.headers = {
      authorization: `Bearer ${token}`,
    };

    // Act
    const middleware = auth(UserRole.ADMIN);
    middleware(mockRequest as Request, mockResponse as Response, nextFunction);

    // Assert
    expect(nextFunction).toHaveBeenCalled();
    expect((mockRequest as any).user).toBeDefined();
    expect((mockRequest as any).user.userId).toBe("user-123");
  });

  it("should return 401 without token", () => {
    // Act
    const middleware = auth(UserRole.ADMIN);
    middleware(mockRequest as Request, mockResponse as Response, nextFunction);

    // Assert
    expect(mockResponse.status).toHaveBeenCalledWith(401);
    expect(nextFunction).not.toHaveBeenCalled();
  });

  it("should return 403 for insufficient role", () => {
    // Arrange
    const token = generateTestToken("user-123", UserRole.PATIENT);
    mockRequest.headers = {
      authorization: `Bearer ${token}`,
    };

    // Act
    const middleware = auth(UserRole.ADMIN);
    middleware(mockRequest as Request, mockResponse as Response, nextFunction);

    // Assert
    expect(mockResponse.status).toHaveBeenCalledWith(403);
    expect(nextFunction).not.toHaveBeenCalled();
  });
});
```

---

## ‚úÖ Testing Checklist

### Unit Tests

- [ ] Service layer tests (all methods)
- [ ] Controller tests (request handling)
- [ ] Utility function tests
- [ ] Helper function tests
- [ ] Validation schema tests
- [ ] Error handling tests

### Integration Tests

- [ ] GET endpoints (list, detail)
- [ ] POST endpoints (create)
- [ ] PATCH/PUT endpoints (update)
- [ ] DELETE endpoints (soft delete)
- [ ] Authentication tests
- [ ] Authorization tests (role-based)
- [ ] Query parameter filtering
- [ ] Pagination tests
- [ ] Search functionality tests

### Database Tests

- [ ] CRUD operations
- [ ] Transactions and rollbacks
- [ ] Constraints validation
- [ ] Relationship tests
- [ ] Cascade delete tests

### Coverage

- [ ] Overall coverage >80%
- [ ] Service coverage >90%
- [ ] Controller coverage >85%
- [ ] Middleware coverage >90%

---

## üéØ Acceptance Criteria

1. ‚úÖ Jest configured with TypeScript
2. ‚úÖ Test database setup and teardown
3. ‚úÖ Unit tests for all services
4. ‚úÖ Integration tests for all API endpoints
5. ‚úÖ Authentication/authorization tests
6. ‚úÖ Middleware tests complete
7. ‚úÖ Code coverage >80%
8. ‚úÖ All tests pass in CI/CD
9. ‚úÖ Test execution time <2 minutes
10. ‚úÖ Mocking strategies implemented

---

## üìä Coverage Report Example

```
----------------------|---------|----------|---------|---------|
File                  | % Stmts | % Branch | % Funcs | % Lines |
----------------------|---------|----------|---------|---------|
All files             |   87.5  |   82.3   |   91.2  |   88.1  |
 services/            |   92.1  |   88.5   |   95.3  |   93.2  |
  doctor.service.ts   |   94.5  |   91.2   |   97.1  |   95.3  |
 controllers/         |   89.3  |   85.1   |   92.7  |   90.1  |
  doctor.controller.ts|   91.2  |   87.3   |   94.5  |   92.1  |
 middlewares/         |   95.7  |   93.2   |   98.1  |   96.3  |
  auth.ts             |   98.2  |   96.5   |  100.0  |   99.1  |
----------------------|---------|----------|---------|---------|
```

---

## üìñ Resources

- [Jest Documentation](https://jestjs.io/docs/getting-started)
- [Supertest GitHub](https://github.com/ladjs/supertest)
- [Testing Best Practices](https://testingjavascript.com/)
- [Prisma Testing Guide](https://www.prisma.io/docs/guides/testing)

---

**Task Status**: üìù Ready for implementation  
**Estimated Completion**: 1-2 weeks  
**Impact**: Prevents bugs, improves code quality, enables confident refactoring

---

_Testing is not optional - it's essential for production-ready applications. Aim for 80%+ coverage!_ ‚úÖ
