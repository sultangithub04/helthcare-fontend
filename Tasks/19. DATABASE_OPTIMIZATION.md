# Database Optimization & Performance Tuning Guide

## ðŸ“Š Current Database Performance Analysis

### Identified Performance Issues

Based on the Prisma schema analysis, here are critical performance bottlenecks:

| Query Type                        | Current Performance | Bottleneck                          | Priority    |
| --------------------------------- | ------------------- | ----------------------------------- | ----------- |
| Doctor search with filters        | ~800ms              | No indexes on searchable fields     | ðŸ”´ CRITICAL |
| Appointment list (patient/doctor) | ~700ms              | Missing composite indexes           | ðŸ”´ CRITICAL |
| Dashboard statistics              | ~1200ms             | N+1 queries, no aggregation indexes | ðŸ”´ CRITICAL |
| Review aggregation                | ~900ms              | No index on rating field            | ðŸŸ  HIGH     |
| Specialty filtering               | ~600ms              | Junction table without indexes      | ðŸŸ  HIGH     |
| Doctor schedules                  | ~500ms              | No index on date ranges             | ðŸŸ¡ MEDIUM   |

---

## ðŸŽ¯ Optimization Strategies

### 1. Add Critical Database Indexes

#### Problem: Full Table Scans

**Current**: Searching doctors without indexes causes full table scans

**Solution**: Add strategic indexes

**File**: `backend/prisma/schema/user.prisma`

```prisma
model User {
  id                 String     @id @default(uuid())
  email              String     @unique
  password           String
  role               UserRole
  needPasswordChange Boolean    @default(true)
  status             UserStatus @default(ACTIVE)
  createdAt          DateTime   @default(now())
  updatedAt          DateTime   @updatedAt

  admin              Admin?
  doctor             Doctor?
  patient            Patient?

  // âœ… NEW INDEXES
  @@index([email, status])      // For login queries
  @@index([role, status])       // For role-based filtering
  @@index([createdAt])          // For sorting by join date
  @@map("users")
}
```

**File**: `backend/prisma/schema/user.prisma` (Doctor model)

```prisma
model Doctor {
  id                  String              @id @default(uuid())
  name                String
  email               String              @unique
  profilePhoto        String?
  contactNumber       String
  address             String?
  registrationNumber  String
  experience          Int                 @default(0)
  gender              Gender
  appointmentFee      Int
  qualification       String
  currentWorkingPlace String
  designation         String
  isDeleted           Boolean             @default(false)
  averageRating       Float               @default(0.0)
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  user                User                @relation(fields: [email], references: [email])
  doctorSpecialties   DoctorSpecialties[]
  doctorSchedules     DoctorSchedules[]
  appointment         Appointment[]
  prescription        Prescription[]
  review              Review[]

  // âœ… NEW INDEXES
  @@index([name])                       // For name search
  @@index([isDeleted, averageRating])   // For active doctors sorted by rating
  @@index([appointmentFee])             // For price filtering
  @@index([experience])                 // For experience filtering
  @@index([gender])                     // For gender filtering
  @@index([currentWorkingPlace])        // For location filtering

  // âœ… COMPOSITE INDEXES for common query patterns
  @@index([isDeleted, averageRating, appointmentFee]) // Most common filter combo
  @@index([gender, isDeleted])          // Gender filter with active check

  // âœ… FULL TEXT SEARCH INDEX (PostgreSQL specific)
  @@index([name, qualification, designation], type: Gin)

  @@map("doctors")
}
```

**File**: `backend/prisma/schema/appointment.prisma`

```prisma
model Appointment {
  id              String            @id @default(uuid())
  patientId       String
  patient         Patient           @relation(fields: [patientId], references: [id])
  doctorId        String
  doctor          Doctor            @relation(fields: [doctorId], references: [id])
  scheduleId      String            @unique
  schedule        Schedule          @relation(fields: [scheduleId], references: [id])
  videoCallingId  String
  status          AppointmentStatus @default(SCHEDULED)
  paymentStatus   PaymentStatus     @default(UNPAID)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  doctorSchedules DoctorSchedules?
  payment         Payment?
  prescription    Prescription?
  review          Review?

  // âœ… NEW INDEXES
  @@index([patientId, status])          // Patient's appointments by status
  @@index([doctorId, status])           // Doctor's appointments by status
  @@index([status, paymentStatus])      // For admin filtering
  @@index([createdAt])                  // For chronological sorting
  @@index([scheduleId])                 // For schedule lookup

  // âœ… COMPOSITE INDEXES for dashboard queries
  @@index([patientId, createdAt])       // Patient's recent appointments
  @@index([doctorId, createdAt])        // Doctor's recent appointments
  @@index([status, createdAt])          // Active appointments timeline
  @@index([paymentStatus, createdAt])   // Payment tracking

  @@map("appointments")
}
```

**File**: `backend/prisma/schema/schedule.prisma`

```prisma
model Schedule {
  id              String            @id @default(uuid())
  startDateTime   DateTime
  endDateTime     DateTime
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  doctorSchedules DoctorSchedules[]
  appointment     Appointment?

  // âœ… NEW INDEXES
  @@index([startDateTime])              // For date range queries
  @@index([endDateTime])                // For availability checks
  @@index([startDateTime, endDateTime]) // For overlap detection

  @@map("schedules")
}

model DoctorSchedules {
  doctorId      String
  doctor        Doctor       @relation(fields: [doctorId], references: [id])
  scheduleId    String
  schedule      Schedule     @relation(fields: [scheduleId], references: [id])
  isBooked      Boolean      @default(false)
  appointmentId String?      @unique
  appointment   Appointment? @relation(fields: [appointmentId], references: [id])
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  @@id([doctorId, scheduleId])

  // âœ… NEW INDEXES
  @@index([doctorId, isBooked])         // For available slots
  @@index([scheduleId, isBooked])       // For schedule availability
  @@index([createdAt])                  // For recent schedules

  @@map("doctor_schedules")
}
```

**File**: `backend/prisma/schema/specialty.prisma`

```prisma
model DoctorSpecialties {
  specialitiesId String
  specialities   Specialties @relation(fields: [specialitiesId], references: [id])
  doctorId       String
  doctor         Doctor      @relation(fields: [doctorId], references: [id])
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  @@id([specialitiesId, doctorId])

  // âœ… NEW INDEXES for junction table queries
  @@index([specialitiesId])             // Doctors by specialty
  @@index([doctorId])                   // Specialties of a doctor

  @@map("doctor_specialties")
}
```

**File**: `backend/prisma/schema/appointment.prisma` (Review model)

```prisma
model Review {
  id            String      @id @default(uuid())
  patientId     String
  patient       Patient     @relation(fields: [patientId], references: [id])
  doctorId      String
  doctor        Doctor      @relation(fields: [doctorId], references: [id])
  appointmentId String      @unique
  appointment   Appointment @relation(fields: [appointmentId], references: [id])
  rating        Float
  comment       String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // âœ… NEW INDEXES
  @@index([doctorId, rating])           // For doctor's review stats
  @@index([patientId])                  // For patient's reviews
  @@index([rating])                     // For filtering by rating
  @@index([createdAt])                  // For recent reviews
  @@index([doctorId, createdAt])        // Doctor's recent reviews

  @@map("reviews")
}
```

### Run Migration

```bash
cd backend
pnpm db:push

# Or create a migration
pnpm prisma migrate dev --name add_performance_indexes
```

---

## 2. Optimize N+1 Query Problems

### Problem: Dashboard Statistics Query

**Current (Inefficient)**:

```typescript
// âŒ BAD: N+1 queries (1 query + N doctor queries)
const appointments = await prisma.appointment.findMany({
  where: { doctorId },
});

// For each appointment, fetch doctor details (N queries)
for (const apt of appointments) {
  const doctor = await prisma.doctor.findUnique({
    where: { id: apt.doctorId },
  });
}
```

**Optimized**:

```typescript
// âœ… GOOD: Single query with includes
const appointments = await prisma.appointment.findMany({
  where: { doctorId },
  include: {
    doctor: {
      select: {
        id: true,
        name: true,
        profilePhoto: true,
      },
    },
    patient: {
      select: {
        id: true,
        name: true,
      },
    },
    schedule: true,
  },
});
```

**Even Better - Use Aggregations**:

```typescript
// âœ… BEST: Use database aggregations instead of fetching all records
const stats = await prisma.appointment.groupBy({
  by: ["status"],
  where: { doctorId },
  _count: {
    id: true,
  },
});

// Result: { status: 'SCHEDULED', _count: { id: 25 } }
```

---

## 3. Implement Database-Level Aggregations

### Dashboard Stats Optimization

**File**: `backend/src/app/modules/Meta/meta.service.ts`

```typescript
const getDoctorDashboardMetrics = async (doctorId: string) => {
  // âŒ BEFORE: Multiple queries
  const totalAppointments = await prisma.appointment.count({
    where: { doctorId },
  });
  const completedAppointments = await prisma.appointment.count({
    where: { doctorId, status: "COMPLETED" },
  });
  const revenue = await prisma.payment.aggregate({
    where: { appointment: { doctorId } },
    _sum: { amount: true },
  });

  // âœ… AFTER: Single transaction with parallel queries
  const [appointmentStats, revenueStats, reviewStats] =
    await prisma.$transaction([
      // Appointment stats
      prisma.appointment.groupBy({
        by: ["status", "paymentStatus"],
        where: { doctorId },
        _count: { id: true },
      }),

      // Revenue stats
      prisma.payment.aggregate({
        where: {
          appointment: { doctorId },
          status: "PAID",
        },
        _sum: { amount: true },
        _count: { id: true },
      }),

      // Review stats
      prisma.review.aggregate({
        where: { doctorId },
        _avg: { rating: true },
        _count: { id: true },
      }),
    ]);

  return {
    appointments: {
      total: appointmentStats.reduce((sum, stat) => sum + stat._count.id, 0),
      byStatus: appointmentStats,
    },
    revenue: {
      total: revenueStats._sum.amount || 0,
      transactions: revenueStats._count.id,
    },
    reviews: {
      averageRating: reviewStats._avg.rating || 0,
      totalReviews: reviewStats._count.id,
    },
  };
};
```

---

## 4. Implement Query Result Caching

### Problem: Repeated Expensive Queries

**Solution**: Combine with Redis caching (see TASK_04_REDIS_CACHING.md)

```typescript
const getAllDoctors = async (filters: any, options: any) => {
  // 1. Check cache first
  const cacheKey = `doctors:list:${hash(filters)}:${hash(options)}`;
  const cached = await redis.get(cacheKey);
  if (cached) return cached;

  // 2. Execute optimized query
  const result = await prisma.doctor.findMany({
    where: buildWhereClause(filters),
    include: {
      doctorSpecialties: {
        include: {
          specialities: {
            select: { id: true, title: true },
          },
        },
      },
      _count: {
        select: {
          review: true,
          appointment: true,
        },
      },
    },
    take: options.limit,
    skip: options.skip,
    orderBy: { averageRating: "desc" },
  });

  // 3. Cache result
  await redis.setex(cacheKey, 300, JSON.stringify(result)); // 5 min TTL

  return result;
};
```

---

## 5. Use Database Views for Complex Queries

### Problem: Repeated Complex Joins

**Solution**: Create PostgreSQL views for frequently used complex queries

```sql
-- Create a view for doctor summary
CREATE VIEW doctor_summary AS
SELECT
  d.id,
  d.name,
  d.email,
  d.profile_photo,
  d.appointment_fee,
  d.experience,
  d.average_rating,
  d.is_deleted,
  COUNT(DISTINCT a.id) as total_appointments,
  COUNT(DISTINCT r.id) as total_reviews,
  ARRAY_AGG(DISTINCT s.title) as specialties
FROM doctors d
LEFT JOIN appointments a ON a.doctor_id = d.id
LEFT JOIN reviews r ON r.doctor_id = d.id
LEFT JOIN doctor_specialties ds ON ds.doctor_id = d.id
LEFT JOIN specialties s ON s.id = ds.specialities_id
GROUP BY d.id;

-- Query the view (much faster)
SELECT * FROM doctor_summary WHERE is_deleted = false ORDER BY average_rating DESC;
```

**Prisma Integration**:

```prisma
// Add to schema
model DoctorSummary {
  id                String   @id
  name              String
  email             String
  profilePhoto      String?
  appointmentFee    Int
  experience        Int
  averageRating     Float
  isDeleted         Boolean
  totalAppointments Int
  totalReviews      Int
  specialties       String[]

  @@map("doctor_summary")
}
```

---

## 6. Implement Connection Pooling

**File**: `backend/prisma/prisma.config.ts`

```typescript
import { PrismaClient } from "@prisma/client";
import { Pool } from "@prisma/adapter-pg";
import pg from "pg";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20, // Maximum connections in pool
  idleTimeoutMillis: 30000, // Close idle connections after 30s
  connectionTimeoutMillis: 2000, // Timeout if pool is exhausted
});

const prisma = new PrismaClient({
  adapter: pool,
  log:
    process.env.NODE_ENV === "development"
      ? ["query", "error", "warn"]
      : ["error"],
});

export default prisma;
```

---

## 7. Optimize Pagination

### Problem: Slow Offset Pagination at Large Offsets

**Current (Inefficient)**:

```typescript
// âŒ BAD: OFFSET pagination is slow for large offsets
const page = 100;
const limit = 10;
const skip = (page - 1) * limit; // 990 records skipped!

const doctors = await prisma.doctor.findMany({
  skip, // Database still scans 990 rows
  take: limit,
});
```

**Solution: Cursor-Based Pagination**:

```typescript
// âœ… GOOD: Cursor-based pagination
const doctors = await prisma.doctor.findMany({
  take: limit,
  skip: 1, // Skip the cursor
  cursor: lastId ? { id: lastId } : undefined,
  orderBy: { id: "asc" },
});

// Return with next cursor
return {
  data: doctors,
  nextCursor: doctors.length === limit ? doctors[doctors.length - 1].id : null,
};
```

---

## 8. Monitoring & Analysis Tools

### Query Performance Monitoring

**File**: `backend/src/middlewares/queryMonitor.ts`

```typescript
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient({
  log: [
    {
      emit: "event",
      level: "query",
    },
  ],
});

prisma.$on("query", (e) => {
  if (e.duration > 100) {
    // Queries taking >100ms
    console.warn("âš ï¸ Slow query detected:", {
      query: e.query,
      duration: `${e.duration}ms`,
      params: e.params,
    });
  }
});
```

### Database Connection Monitoring

```typescript
setInterval(async () => {
  const metrics = await prisma.$metrics.json();
  console.log("Database Metrics:", {
    activeConnections: metrics.counters.find(
      (c) => c.key === "connection.active"
    )?.value,
    queryCount: metrics.counters.find((c) => c.key === "query.count")?.value,
  });
}, 60000); // Every minute
```

---

## ðŸŽ¯ Performance Benchmarks

### Before Optimization

| Query                  | Time   | Records |
| ---------------------- | ------ | ------- |
| Doctor list (filtered) | 800ms  | 50      |
| Doctor details         | 600ms  | 1       |
| Appointment list       | 700ms  | 20      |
| Dashboard stats        | 1200ms | -       |

### After Optimization (Target)

| Query                  | Time   | Records | Improvement |
| ---------------------- | ------ | ------- | ----------- |
| Doctor list (filtered) | <100ms | 50      | 88% faster  |
| Doctor details         | <50ms  | 1       | 92% faster  |
| Appointment list       | <80ms  | 20      | 89% faster  |
| Dashboard stats        | <200ms | -       | 83% faster  |

---

## âœ… Optimization Checklist

### Immediate Actions

- [ ] Add indexes to all frequently queried fields
- [ ] Add composite indexes for common filter combinations
- [ ] Implement connection pooling
- [ ] Fix N+1 query problems
- [ ] Add query monitoring

### Short-term Improvements

- [ ] Implement cursor-based pagination
- [ ] Use database aggregations
- [ ] Create views for complex queries
- [ ] Add Redis caching layer
- [ ] Optimize dashboard queries

### Long-term Strategies

- [ ] Implement read replicas
- [ ] Database partitioning for large tables
- [ ] Archival strategy for old records
- [ ] Regular VACUUM and ANALYZE
- [ ] Query performance testing in CI/CD

---

## ðŸ“š Additional Resources

- [Prisma Performance Guide](https://www.prisma.io/docs/guides/performance-and-optimization)
- [PostgreSQL Indexing Strategies](https://www.postgresql.org/docs/current/indexes.html)
- [Database Query Optimization](https://use-the-index-luke.com/)

---

**Next Steps**:

1. Run migrations to add all indexes
2. Implement query monitoring
3. Measure before/after performance
4. Document improvements

**Related**: `TASK_04_REDIS_CACHING.md`, `PERFORMANCE_TESTING.md`
