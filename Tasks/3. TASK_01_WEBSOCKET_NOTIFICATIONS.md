# Task 01: WebSocket Implementation for Real-Time Notifications

## ðŸ“‹ Task Overview

**Difficulty**: ðŸ”´ **ADVANCED**  
**Estimated Time**: 1-2 weeks  
**Priority**: HIGH  
**Category**: Real-Time Communication

### Objective

Implement a comprehensive real-time notification system using Socket.io to push live updates to users across different roles (Admin, Doctor, Patient) without requiring page refreshes.

### Learning Outcomes

- Master WebSocket protocol and Socket.io library
- Understand real-time event-driven architecture
- Implement room-based broadcasting
- Handle connection lifecycle (connect, disconnect, reconnect)
- Manage authentication in WebSocket context
- Scale WebSocket connections with Redis adapter

---

## ðŸŽ¯ Requirements

### Functional Requirements

1. **User Connection Management**

   - Users authenticate via JWT token when connecting
   - Each user joins role-specific and user-specific rooms
   - Connection state persists across page navigation
   - Graceful reconnection on network interruption

2. **Notification Types**
   | Event Type | Triggered When | Recipients | Priority |
   |------------|---------------|------------|----------|
   | `appointment:created` | New appointment booked | Doctor, Admin | High |
   | `appointment:updated` | Appointment status changed | Patient, Doctor, Admin | High |
   | `appointment:canceled` | Appointment canceled | Patient, Doctor, Admin | High |
   | `payment:completed` | Payment successful | Patient, Admin | High |
   | `prescription:created` | New prescription issued | Patient | Medium |
   | `review:created` | New review submitted | Doctor, Admin | Low |
   | `schedule:updated` | Doctor schedule changed | Admin | Medium |
   | `user:status_changed` | User blocked/activated | Affected user | High |

3. **Admin Broadcast**

   - Admins can send system-wide announcements
   - Scheduled maintenance notifications
   - Emergency alerts

4. **Online Status**
   - Show online/offline status for doctors
   - Last seen timestamp
   - Active user count per role

### Technical Requirements

1. **Technology Stack**

   - **Backend**: Socket.io (server)
   - **Frontend**: Socket.io-client
   - **Authentication**: JWT token validation
   - **Scaling**: Socket.io Redis adapter (for multi-instance)
   - **Storage**: PostgreSQL (notification history)

2. **Performance**

   - Connection establishment < 500ms
   - Event delivery latency < 100ms
   - Support 1000+ concurrent connections
   - Automatic reconnection with exponential backoff

3. **Security**
   - JWT validation on connection
   - Room-based authorization
   - Rate limiting on event emission
   - No XSS/CSRF vulnerabilities

---

## ðŸ—ï¸ Architecture Design

### System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         WebSocket          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client    â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Socket.io    â”‚
â”‚  (Browser)  â”‚         (WSS/HTTPS)        â”‚   Server     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                                                  â”‚
                                                  â”‚ Pub/Sub
                                                  â–¼
                                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                           â”‚    Redis     â”‚
                                           â”‚   Adapter    â”‚
                                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                  â”‚
                                                  â”‚
                                           â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
                                           â”‚  PostgreSQL  â”‚
                                           â”‚ (Notificationâ”‚
                                           â”‚   History)   â”‚
                                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Flow

```
1. User Action (e.g., Book Appointment)
        â”‚
        â–¼
2. API Request (POST /api/v1/appointment)
        â”‚
        â–¼
3. Database Transaction
        â”‚
        â–¼
4. Emit Socket Event (appointment:created)
        â”‚
        â–¼
5. Socket.io Server Receives Event
        â”‚
        â–¼
6. Find Target Rooms (doctor:{doctorId}, admin, patient:{patientId})
        â”‚
        â–¼
7. Broadcast to All Clients in Rooms
        â”‚
        â–¼
8. Clients Receive & Display Notification
        â”‚
        â–¼
9. Save Notification to Database (History)
```

---

## ðŸ“ Implementation Guide

### Phase 1: Backend Setup

#### Step 1.1: Install Dependencies

```bash
cd backend
pnpm install socket.io socket.io-redis-adapter ioredis
```

**Package Versions**:

```json
{
  "socket.io": "^4.7.2",
  "socket.io-redis-adapter": "^8.2.1",
  "ioredis": "^5.3.2"
}
```

#### Step 1.2: Create Socket Server

**File**: `backend/src/socket/socket.server.ts`

```typescript
import { Server as SocketServer } from "socket.io";
import { createAdapter } from "@socket.io/redis-adapter";
import { createClient } from "redis";
import { Server as HttpServer } from "http";
import config from "../config";
import { jwtHelpers } from "../helpers/jwtHelpers";
import { Secret } from "jsonwebtoken";

// Extend Express Request to include user
declare module "socket.io" {
  interface Socket {
    user?: {
      userId: string;
      email: string;
      role: string;
    };
  }
}

export function initializeSocket(httpServer: HttpServer) {
  const io = new SocketServer(httpServer, {
    cors: {
      origin: [
        "http://localhost:3000",
        "http://localhost:3001",
        process.env.FRONTEND_URL || "http://localhost:3000",
      ],
      credentials: true,
    },
    pingTimeout: 60000,
    pingInterval: 25000,
  });

  // Redis adapter for scaling (optional but recommended)
  if (config.redis?.host) {
    const pubClient = createClient({
      url: `redis://${config.redis.host}:${config.redis.port}`,
    });
    const subClient = pubClient.duplicate();

    Promise.all([pubClient.connect(), subClient.connect()]).then(() => {
      io.adapter(createAdapter(pubClient, subClient));
      console.log("âœ… Socket.io Redis adapter connected");
    });
  }

  // Authentication middleware
  io.use(async (socket, next) => {
    try {
      const token =
        socket.handshake.auth.token || socket.handshake.headers.authorization;

      if (!token) {
        return next(new Error("Authentication token missing"));
      }

      const decoded = jwtHelpers.verifyToken(
        token,
        config.jwt.jwt_secret as Secret
      );

      // Attach user info to socket
      socket.user = {
        userId: decoded.userId,
        email: decoded.email,
        role: decoded.role,
      };

      next();
    } catch (error) {
      next(new Error("Invalid authentication token"));
    }
  });

  // Connection handling
  io.on("connection", (socket) => {
    const user = socket.user!;
    console.log(`âœ… User connected: ${user.email} (${user.role})`);

    // Join user-specific room
    socket.join(`user:${user.userId}`);

    // Join role-specific room
    socket.join(`role:${user.role.toLowerCase()}`);

    // If doctor, join doctor-specific room
    if (user.role === "DOCTOR") {
      socket.join(`doctor:${user.userId}`);
    }

    // If patient, join patient-specific room
    if (user.role === "PATIENT") {
      socket.join(`patient:${user.userId}`);
    }

    // Broadcast online status
    io.to(`role:admin`).emit("user:online", {
      userId: user.userId,
      email: user.email,
      role: user.role,
      timestamp: new Date().toISOString(),
    });

    // Handle disconnection
    socket.on("disconnect", (reason) => {
      console.log(`âŒ User disconnected: ${user.email} (${reason})`);

      io.to(`role:admin`).emit("user:offline", {
        userId: user.userId,
        email: user.email,
        role: user.role,
        timestamp: new Date().toISOString(),
        reason,
      });
    });

    // Handle errors
    socket.on("error", (error) => {
      console.error("Socket error:", error);
    });
  });

  return io;
}

export type SocketIOServer = ReturnType<typeof initializeSocket>;
```

#### Step 1.3: Integrate Socket Server with Express

**File**: `backend/src/server.ts`

```typescript
import { Server } from "http";
import app from "./app";
import seedSuperAdmin from "./helpers/seed";
import config from "./config";
import { initializeSocket } from "./socket/socket.server";

async function bootstrap() {
  let server: Server;

  try {
    await seedSuperAdmin();

    // Create HTTP server
    server = app.listen(config.port, () => {
      console.log(`ðŸš€ Server is running on http://localhost:${config.port}`);
    });

    // Initialize Socket.io
    const io = initializeSocket(server);

    // Make io available globally for emitting events from services
    (global as any).io = io;
    console.log("âœ… Socket.io initialized");

    const exitHandler = () => {
      if (server) {
        server.close(() => {
          console.log("Server closed gracefully.");
          process.exit(1);
        });
      } else {
        process.exit(1);
      }
    };

    process.on("unhandledRejection", (error) => {
      console.log("Unhandled Rejection detected...");
      if (server) {
        server.close(() => {
          console.log(error);
          process.exit(1);
        });
      } else {
        process.exit(1);
      }
    });
  } catch (error) {
    console.error("Error during server startup:", error);
    process.exit(1);
  }
}

bootstrap();
```

#### Step 1.4: Create Notification Service

**File**: `backend/src/app/modules/Notification/notification.service.ts`

```typescript
import { SocketIOServer } from "../../../socket/socket.server";
import prisma from "../../../shared/prisma";

export enum NotificationType {
  APPOINTMENT_CREATED = "APPOINTMENT_CREATED",
  APPOINTMENT_UPDATED = "APPOINTMENT_UPDATED",
  APPOINTMENT_CANCELED = "APPOINTMENT_CANCELED",
  PAYMENT_COMPLETED = "PAYMENT_COMPLETED",
  PRESCRIPTION_CREATED = "PRESCRIPTION_CREATED",
  REVIEW_CREATED = "REVIEW_CREATED",
  SCHEDULE_UPDATED = "SCHEDULE_UPDATED",
  SYSTEM_ANNOUNCEMENT = "SYSTEM_ANNOUNCEMENT",
}

interface NotificationPayload {
  type: NotificationType;
  title: string;
  message: string;
  data?: any;
  priority?: "low" | "medium" | "high";
  actionUrl?: string;
}

const emitNotification = async (
  userId: string | string[],
  payload: NotificationPayload
) => {
  const io: SocketIOServer = (global as any).io;

  if (!io) {
    console.error("Socket.io not initialized");
    return;
  }

  const userIds = Array.isArray(userId) ? userId : [userId];

  // Save to database
  const notifications = await prisma.notification.createMany({
    data: userIds.map((id) => ({
      userId: id,
      type: payload.type,
      title: payload.title,
      message: payload.message,
      data: payload.data || {},
      priority: payload.priority || "medium",
      actionUrl: payload.actionUrl,
    })),
  });

  // Emit to connected clients
  userIds.forEach((id) => {
    io.to(`user:${id}`).emit("notification", {
      ...payload,
      timestamp: new Date().toISOString(),
    });
  });

  return notifications;
};

const emitToRole = async (
  role: "ADMIN" | "DOCTOR" | "PATIENT",
  payload: NotificationPayload
) => {
  const io: SocketIOServer = (global as any).io;

  if (!io) {
    console.error("Socket.io not initialized");
    return;
  }

  io.to(`role:${role.toLowerCase()}`).emit("notification", {
    ...payload,
    timestamp: new Date().toISOString(),
  });

  // Optionally save to all users of that role
  const users = await prisma.user.findMany({
    where: { role },
    select: { id: true },
  });

  await prisma.notification.createMany({
    data: users.map((user) => ({
      userId: user.id,
      type: payload.type,
      title: payload.title,
      message: payload.message,
      data: payload.data || {},
      priority: payload.priority || "medium",
      actionUrl: payload.actionUrl,
    })),
  });
};

const broadcastToAll = async (payload: NotificationPayload) => {
  const io: SocketIOServer = (global as any).io;

  if (!io) {
    console.error("Socket.io not initialized");
    return;
  }

  io.emit("notification", {
    ...payload,
    timestamp: new Date().toISOString(),
  });
};

export const NotificationService = {
  emitNotification,
  emitToRole,
  broadcastToAll,
};
```

#### Step 1.5: Add Notification Schema to Prisma

**File**: `backend/prisma/schema/notification.prisma`

```prisma
model Notification {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  type      NotificationType
  title     String
  message   String
  data      Json?
  priority  NotificationPriority @default(MEDIUM)
  actionUrl String?

  isRead    Boolean  @default(false)
  readAt    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, isRead])
  @@index([userId, createdAt])
  @@map("notifications")
}

enum NotificationType {
  APPOINTMENT_CREATED
  APPOINTMENT_UPDATED
  APPOINTMENT_CANCELED
  PAYMENT_COMPLETED
  PRESCRIPTION_CREATED
  REVIEW_CREATED
  SCHEDULE_UPDATED
  SYSTEM_ANNOUNCEMENT
}

enum NotificationPriority {
  LOW
  MEDIUM
  HIGH
}
```

**Update User schema to include notifications**:

```prisma
model User {
  // ... existing fields
  notifications Notification[]
}
```

Run migration:

```bash
cd backend
pnpm db:push
```

#### Step 1.6: Integrate Notifications in Services

**Example**: Update Appointment Service

**File**: `backend/src/app/modules/Appointment/appointment.service.ts`

```typescript
import {
  NotificationService,
  NotificationType,
} from "../Notification/notification.service";

const createAppointment = async (user: IAuthUser, payload: any) => {
  // ... existing appointment creation logic

  const result = await prisma.$transaction(async (tnx) => {
    const appointmentData = await tnx.appointment.create({
      data: {
        patientId: patientData.id,
        doctorId: doctorData.id,
        scheduleId: payload.scheduleId,
        videoCallingId,
      },
      include: {
        doctor: true,
        patient: true,
        schedule: true,
      },
    });

    // ... rest of transaction

    return { paymentUrl: session.url, appointment: appointmentData };
  });

  // âœ… NEW: Emit real-time notification
  await NotificationService.emitNotification(
    [result.appointment.doctorId, result.appointment.patientId],
    {
      type: NotificationType.APPOINTMENT_CREATED,
      title: "New Appointment Booked",
      message: `Appointment scheduled for ${new Date(
        result.appointment.schedule.startDateTime
      ).toLocaleString()}`,
      priority: "high",
      actionUrl: `/dashboard/my-appointments`,
      data: {
        appointmentId: result.appointment.id,
      },
    }
  );

  // Notify admins
  await NotificationService.emitToRole("ADMIN", {
    type: NotificationType.APPOINTMENT_CREATED,
    title: "New Appointment",
    message: `${result.appointment.patient.name} booked with Dr. ${result.appointment.doctor.name}`,
    priority: "medium",
    actionUrl: `/admin/dashboard/appointments-management`,
  });

  return result;
};
```

---

### Phase 2: Frontend Setup

#### Step 2.1: Install Dependencies

```bash
cd frontend
npm install socket.io-client
```

#### Step 2.2: Create Socket Context

**File**: `src/contexts/SocketContext.tsx`

```typescript
"use client";

import { createContext, useContext, useEffect, useState } from "react";
import { io, Socket } from "socket.io-client";
import { getAccessToken } from "@/services/auth/tokenHandlers";

interface SocketContextType {
  socket: Socket | null;
  isConnected: boolean;
  notifications: Notification[];
}

const SocketContext = createContext<SocketContextType>({
  socket: null,
  isConnected: false,
  notifications: [],
});

export function SocketProvider({ children }: { children: React.ReactNode }) {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [notifications, setNotifications] = useState<any[]>([]);

  useEffect(() => {
    const token = getAccessToken();

    if (!token) {
      console.log("No token, skipping socket connection");
      return;
    }

    const socketInstance = io(
      process.env.NEXT_PUBLIC_SOCKET_URL || "http://localhost:5000",
      {
        auth: { token },
        transports: ["websocket", "polling"],
        reconnection: true,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 5000,
        reconnectionAttempts: 5,
      }
    );

    socketInstance.on("connect", () => {
      console.log("âœ… Socket connected");
      setIsConnected(true);
    });

    socketInstance.on("disconnect", (reason) => {
      console.log("âŒ Socket disconnected:", reason);
      setIsConnected(false);
    });

    socketInstance.on("notification", (data) => {
      console.log("ðŸ“¬ New notification:", data);
      setNotifications((prev) => [data, ...prev]);

      // Show toast notification
      // You can integrate with sonner here
    });

    setSocket(socketInstance);

    return () => {
      socketInstance.disconnect();
    };
  }, []);

  return (
    <SocketContext.Provider value={{ socket, isConnected, notifications }}>
      {children}
    </SocketContext.Provider>
  );
}

export const useSocket = () => useContext(SocketContext);
```

#### Step 2.3: Add Socket Provider to Layout

**File**: `src/app/layout.tsx`

```tsx
import { SocketProvider } from "@/contexts/SocketContext";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <SocketProvider>
          {children}
          <Toaster position="bottom-right" richColors />
        </SocketProvider>
      </body>
    </html>
  );
}
```

#### Step 2.4: Create Notification Bell Component

**File**: `src/components/shared/NotificationBell.tsx`

```tsx
"use client";

import { Bell } from "lucide-react";
import { useSocket } from "@/contexts/SocketContext";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { ScrollArea } from "@/components/ui/scroll-area";

export function NotificationBell() {
  const { notifications, isConnected } = useSocket();
  const unreadCount = notifications.filter((n) => !n.isRead).length;

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button variant="ghost" size="icon" className="relative">
          <Bell className="h-5 w-5" />
          {unreadCount > 0 && (
            <Badge
              variant="destructive"
              className="absolute -top-1 -right-1 h-5 w-5 flex items-center justify-center p-0 text-xs"
            >
              {unreadCount > 9 ? "9+" : unreadCount}
            </Badge>
          )}
          {!isConnected && (
            <span className="absolute bottom-0 right-0 h-2 w-2 bg-yellow-500 rounded-full" />
          )}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-80">
        <div className="space-y-2">
          <h3 className="font-semibold">Notifications</h3>
          <ScrollArea className="h-96">
            {notifications.length === 0 ? (
              <p className="text-sm text-muted-foreground text-center py-8">
                No notifications yet
              </p>
            ) : (
              notifications.map((notification, index) => (
                <div
                  key={index}
                  className="p-3 border-b last:border-0 hover:bg-accent cursor-pointer"
                >
                  <h4 className="text-sm font-medium">{notification.title}</h4>
                  <p className="text-xs text-muted-foreground mt-1">
                    {notification.message}
                  </p>
                  <p className="text-xs text-muted-foreground mt-2">
                    {new Date(notification.timestamp).toLocaleString()}
                  </p>
                </div>
              ))
            )}
          </ScrollArea>
        </div>
      </PopoverContent>
    </Popover>
  );
}
```

---

## âœ… Testing Checklist

### Unit Tests

```typescript
// backend/src/__tests__/socket/notification.test.ts
import { NotificationService } from "../../app/modules/Notification/notification.service";

describe("NotificationService", () => {
  it("should emit notification to specific user", async () => {
    // Test implementation
  });

  it("should emit to role", async () => {
    // Test implementation
  });

  it("should broadcast to all users", async () => {
    // Test implementation
  });
});
```

### Integration Tests

1. **Connection Test**: Verify JWT auth on connection
2. **Room Join Test**: Confirm users join correct rooms
3. **Event Emission Test**: Test notification delivery
4. **Disconnection Test**: Verify graceful disconnect handling
5. **Reconnection Test**: Test automatic reconnection

### Manual Testing

- [ ] User connects successfully with valid JWT
- [ ] Connection rejected with invalid JWT
- [ ] Notification appears in real-time
- [ ] Multiple tabs receive same notification
- [ ] Notification persists after refresh
- [ ] Works across different browsers
- [ ] Mobile responsive
- [ ] Handles network interruption

---

## ðŸ“š Documentation Requirements

1. **API Documentation**:

   - Socket events reference
   - Event payload schemas
   - Error codes

2. **Developer Guide**:

   - How to emit notifications from new services
   - Room naming conventions
   - Testing guide

3. **Deployment Guide**:
   - Redis setup for production
   - Nginx WebSocket configuration
   - Load balancing considerations

---

## ðŸš€ Deployment Considerations

### Nginx Configuration for WebSocket

```nginx
location /socket.io/ {
    proxy_pass http://backend:5000;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_cache_bypass $http_upgrade;
    proxy_read_timeout 86400;
}
```

### Environment Variables

```env
# Backend
REDIS_HOST=localhost
REDIS_PORT=6379
SOCKET_PORT=5000

# Frontend
NEXT_PUBLIC_SOCKET_URL=https://api.yourdomain.com
```

---

## ðŸŽ¯ Acceptance Criteria

- [ ] Users receive notifications in real-time (<100ms latency)
- [ ] Notifications persist in database
- [ ] Unread notification count displays correctly
- [ ] Notifications marked as read when clicked
- [ ] System works with 100+ concurrent connections
- [ ] No memory leaks after 24h runtime
- [ ] Graceful degradation if WebSocket fails
- [ ] All tests pass (>80% coverage)
- [ ] Code reviewed and approved
- [ ] Documentation complete

---

## ðŸ“– Additional Resources

- [Socket.io Documentation](https://socket.io/docs/v4/)
- [Redis Adapter Guide](https://socket.io/docs/v4/redis-adapter/)
- [JWT Authentication with Socket.io](https://socket.io/docs/v4/middlewares/)
- [Scaling WebSocket Apps](https://socket.io/docs/v4/using-multiple-nodes/)

---

**Next Task**: See `TASK_02_WEBRTC_VIDEO_CONSULTATION.md`
