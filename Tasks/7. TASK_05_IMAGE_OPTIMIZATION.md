# Task 05: Image Optimization & CDN Strategy

## üìã Task Overview

**Difficulty**: üü¢ **BEGINNER**  
**Estimated Time**: 2-3 days  
**Priority**: MEDIUM  
**Category**: Performance & Scalability

### Objective

Implement comprehensive image optimization strategies using Next.js Image component, Cloudinary transformations, modern image formats (WebP, AVIF), responsive images, lazy loading, and CDN configuration to dramatically improve page load times and Core Web Vitals scores.

### Learning Outcomes

- Master Next.js Image component and optimization features
- Understand modern image formats (WebP, AVIF)
- Implement responsive images with srcset
- Configure Cloudinary transformations
- Optimize Largest Contentful Paint (LCP)
- Implement lazy loading best practices
- Configure CDN caching headers

---

## üéØ Requirements

### Functional Requirements

1. **Image Format Optimization**
   | Current Issue | Solution | Expected Result |
   |---------------|----------|----------------|
   | Large PNG/JPG files (500KB-2MB) | WebP conversion | 60-80% size reduction |
   | No modern format support | AVIF for supported browsers | 70-90% size reduction |
   | No responsive images | srcset with multiple sizes | Load appropriate size per device |
   | No lazy loading | Intersection Observer | Faster initial page load |

2. **Image Delivery**

   - Serve from Cloudinary CDN
   - Auto-select best format (AVIF ‚Üí WebP ‚Üí JPEG)
   - Responsive images for mobile/tablet/desktop
   - Progressive JPEG loading
   - Blur placeholder while loading
   - Proper aspect ratio to prevent layout shift

3. **Optimization Targets**
   - Doctor profile photos (currently ~500KB ‚Üí target <50KB)
   - Specialty icons (currently ~200KB ‚Üí target <20KB)
   - Hero section images (currently ~1.5MB ‚Üí target <150KB)
   - Prescription/report uploads (maintain quality)

### Technical Requirements

1. **Next.js Image Component**

   - Replace all `<img>` tags with `<Image>`
   - Configure `next.config.ts` with Cloudinary domain
   - Set appropriate `sizes` attribute
   - Use `priority` for above-the-fold images
   - Use `loading="lazy"` for below-the-fold

2. **Cloudinary Configuration**

   - Use transformation URLs for automatic optimization
   - Configure quality settings (auto, 80)
   - Enable fetch format (f_auto)
   - Set compression (q_auto)
   - Generate blur placeholders

3. **Performance Targets**
   - Largest Contentful Paint (LCP) < 2.5s
   - Image load time reduction by 70%
   - Cumulative Layout Shift (CLS) < 0.1
   - Total page weight reduction by 50%

---

## üèóÔ∏è Current vs. Optimized Architecture

### Current Image Loading (Problematic)

```
User Request ‚Üí Server ‚Üí Full-size JPEG (1.5MB)
                              ‚Üì
                        Browser downloads entire image
                              ‚Üì
                        Slow render, poor LCP score
```

### Optimized Image Loading

```
User Request ‚Üí Next.js Image component
                    ‚Üì
          Cloudinary CDN (edge server)
                    ‚Üì
      Auto-detect: Browser supports AVIF?
                    ‚Üì
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚Üì                   ‚Üì
      AVIF (30KB)         WebP (50KB)
      [Chrome/Edge]       [Firefox/Safari]
                    ‚Üì
          Lazy load below fold
                    ‚Üì
          Blur placeholder first
                    ‚Üì
          Progressive load full image
```

---

## üìù Implementation Guide

### Phase 1: Next.js Configuration

#### Step 1.1: Configure next.config.ts

**File**: `frontend/next.config.ts`

```typescript
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: "https",
        hostname: "res.cloudinary.com",
        pathname: "/**",
      },
      {
        protocol: "https",
        hostname: "via.placeholder.com",
        pathname: "/**",
      },
    ],
    formats: ["image/avif", "image/webp"],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
    minimumCacheTTL: 60 * 60 * 24 * 365, // 1 year
    dangerouslyAllowSVG: true,
    contentDispositionType: "attachment",
    contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
  },
};

export default nextConfig;
```

#### Step 1.2: Create Image Optimization Utility

**File**: `frontend/src/lib/cloudinary.ts`

```typescript
/**
 * Generate optimized Cloudinary URL with transformations
 */
export function getCloudinaryUrl(
  publicId: string,
  options: {
    width?: number;
    height?: number;
    quality?: number | "auto";
    format?: "auto" | "webp" | "avif" | "jpg" | "png";
    crop?: "fill" | "fit" | "scale" | "thumb";
    gravity?: "auto" | "face" | "center";
    aspectRatio?: string;
    blur?: number;
  } = {}
): string {
  const {
    width,
    height,
    quality = "auto",
    format = "auto",
    crop = "fill",
    gravity = "auto",
    aspectRatio,
    blur,
  } = options;

  const cloudName = process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME;

  if (!publicId || !cloudName) {
    return "/placeholder-image.jpg";
  }

  // Build transformation parameters
  const transformations: string[] = [];

  if (width) transformations.push(`w_${width}`);
  if (height) transformations.push(`h_${height}`);
  if (aspectRatio) transformations.push(`ar_${aspectRatio}`);

  transformations.push(`c_${crop}`);

  if (gravity) transformations.push(`g_${gravity}`);
  if (quality) transformations.push(`q_${quality}`);
  if (format) transformations.push(`f_${format}`);
  if (blur) transformations.push(`e_blur:${blur}`);

  const transformString = transformations.join(",");

  return `https://res.cloudinary.com/${cloudName}/image/upload/${transformString}/${publicId}`;
}

/**
 * Generate blur placeholder data URL
 */
export function getBlurDataURL(publicId: string): string {
  return getCloudinaryUrl(publicId, {
    width: 10,
    quality: 10,
    blur: 1000,
    format: "jpg",
  });
}

/**
 * Extract Cloudinary public ID from full URL
 */
export function extractPublicId(url: string): string {
  if (!url) return "";

  // Extract public ID from Cloudinary URL
  // Example: https://res.cloudinary.com/demo/image/upload/v1234/sample.jpg
  // Returns: sample.jpg
  const match = url.match(/\/upload\/(?:v\d+\/)?(.+?)(?:\.\w+)?$/);
  return match ? match[1] : url;
}

/**
 * Get srcset for responsive images
 */
export function getImageSrcSet(
  publicId: string,
  widths: number[] = [640, 828, 1200, 1920]
): string {
  return widths
    .map((width) => {
      const url = getCloudinaryUrl(publicId, {
        width,
        quality: "auto",
        format: "auto",
      });
      return `${url} ${width}w`;
    })
    .join(", ");
}
```

#### Step 1.3: Create Optimized Image Component

**File**: `frontend/src/components/shared/OptimizedImage.tsx`

```tsx
"use client";

import Image, { ImageProps } from "next/image";
import { useState } from "react";
import {
  getCloudinaryUrl,
  getBlurDataURL,
  extractPublicId,
} from "@/lib/cloudinary";

interface OptimizedImageProps extends Omit<ImageProps, "src" | "alt"> {
  src: string;
  alt: string;
  aspectRatio?: string;
  cloudinaryOptions?: {
    quality?: number | "auto";
    crop?: "fill" | "fit" | "scale" | "thumb";
    gravity?: "auto" | "face" | "center";
  };
}

export function OptimizedImage({
  src,
  alt,
  width,
  height,
  className,
  priority = false,
  aspectRatio,
  cloudinaryOptions = {},
  ...props
}: OptimizedImageProps) {
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false);

  // Extract public ID if Cloudinary URL
  const publicId = extractPublicId(src);
  const isCloudinaryImage = src.includes("cloudinary.com");

  // Generate optimized URL
  const optimizedSrc = isCloudinaryImage
    ? getCloudinaryUrl(publicId, {
        width: typeof width === "number" ? width : undefined,
        height: typeof height === "number" ? height : undefined,
        aspectRatio,
        format: "auto",
        quality: "auto",
        ...cloudinaryOptions,
      })
    : src;

  // Generate blur placeholder
  const blurDataURL = isCloudinaryImage ? getBlurDataURL(publicId) : undefined;

  return (
    <div className={`relative overflow-hidden ${className || ""}`}>
      <Image
        src={hasError ? "/placeholder-image.jpg" : optimizedSrc}
        alt={alt}
        width={width}
        height={height}
        priority={priority}
        placeholder={blurDataURL ? "blur" : "empty"}
        blurDataURL={blurDataURL}
        onLoadingComplete={() => setIsLoading(false)}
        onError={() => setHasError(true)}
        className={`
          duration-700 ease-in-out
          ${
            isLoading
              ? "scale-110 blur-2xl grayscale"
              : "scale-100 blur-0 grayscale-0"
          }
        `}
        {...props}
      />

      {isLoading && (
        <div className="absolute inset-0 bg-gray-200 animate-pulse" />
      )}
    </div>
  );
}
```

---

### Phase 2: Replace Existing Images

#### Step 2.1: Update Doctor Card Component

**File**: `frontend/src/components/modules/Home/TopRatedDoctors.tsx`

**Before** ‚ùå:

```tsx
<img
  src={doctor.profilePhoto}
  alt={doctor.name}
  className="w-full h-48 object-cover"
/>
```

**After** ‚úÖ:

```tsx
import { OptimizedImage } from "@/components/shared/OptimizedImage";

<OptimizedImage
  src={doctor.profilePhoto}
  alt={doctor.name}
  width={300}
  height={300}
  className="w-full h-48 object-cover"
  cloudinaryOptions={{
    crop: "fill",
    gravity: "face",
    quality: 85,
  }}
  sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw"
  priority={false} // Below the fold
/>;
```

#### Step 2.2: Update Hero Section

**File**: `frontend/src/components/modules/Home/Hero.tsx`

**Before** ‚ùå:

```tsx
<img src="/hero-doctor.jpg" alt="Healthcare" className="w-full" />
```

**After** ‚úÖ:

```tsx
import { OptimizedImage } from "@/components/shared/OptimizedImage";

<OptimizedImage
  src="/hero-doctor.jpg"
  alt="Healthcare professional"
  width={1920}
  height={1080}
  priority={true} // Above the fold - critical for LCP
  className="w-full h-auto"
  sizes="100vw"
  cloudinaryOptions={{
    quality: 90,
    format: "auto",
  }}
/>;
```

#### Step 2.3: Update Specialty Icons

**File**: `frontend/src/components/modules/Home/Specialties.tsx`

**Before** ‚ùå:

```tsx
<img src={specialty.icon} alt={specialty.title} className="w-16 h-16" />
```

**After** ‚úÖ:

```tsx
<OptimizedImage
  src={specialty.icon}
  alt={specialty.title}
  width={64}
  height={64}
  className="w-16 h-16"
  cloudinaryOptions={{
    quality: 85,
    format: "auto",
  }}
  loading="lazy"
  sizes="64px"
/>
```

#### Step 2.4: Update Profile Photos (Avatar)

**File**: `frontend/src/components/shared/PublicNavbar.tsx`

```tsx
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { getCloudinaryUrl } from "@/lib/cloudinary";

function UserAvatar({ user }: { user: any }) {
  const optimizedAvatarUrl = getCloudinaryUrl(
    extractPublicId(user.profilePhoto),
    {
      width: 40,
      height: 40,
      crop: "thumb",
      gravity: "face",
      quality: 85,
    }
  );

  return (
    <Avatar>
      <AvatarImage src={optimizedAvatarUrl} alt={user.name} />
      <AvatarFallback>{user.name[0]}</AvatarFallback>
    </Avatar>
  );
}
```

---

### Phase 3: Cloudinary Upload Optimization

#### Step 3.1: Update File Upload Helper

**File**: `backend/src/helpers/fileUploader.ts`

```typescript
import { v2 as cloudinary, UploadApiResponse } from "cloudinary";
import multer from "multer";
import path from "path";
import fs from "fs";
import config from "../config";

cloudinary.config({
  cloud_name: config.cloudinary.cloudName,
  api_key: config.cloudinary.apiKey,
  api_secret: config.cloudinary.apiSecret,
});

interface CloudinaryUploadOptions {
  folder?: string;
  transformation?: any[];
  format?: string;
  quality?: number | "auto";
}

const uploadToCloudinary = async (
  file: Express.Multer.File,
  options: CloudinaryUploadOptions = {}
): Promise<UploadApiResponse> => {
  const {
    folder = "ph-healthcare",
    transformation = [],
    format,
    quality = "auto",
  } = options;

  // Default transformations for optimization
  const defaultTransformations = [
    { quality, fetch_format: "auto" },
    { width: 2000, height: 2000, crop: "limit" }, // Max dimensions
  ];

  const result = await cloudinary.uploader.upload(file.path, {
    folder,
    transformation: [...defaultTransformations, ...transformation],
    format,
    resource_type: "auto",
  });

  // Delete local file after upload
  fs.unlinkSync(file.path);

  return result;
};

// Optimized upload for profile photos
const uploadProfilePhoto = async (
  file: Express.Multer.File
): Promise<string> => {
  const result = await uploadToCloudinary(file, {
    folder: "ph-healthcare/profiles",
    transformation: [
      { width: 500, height: 500, crop: "fill", gravity: "face" },
      { quality: 85 },
    ],
  });

  return result.secure_url;
};

// Optimized upload for specialty icons
const uploadSpecialtyIcon = async (
  file: Express.Multer.File
): Promise<string> => {
  const result = await uploadToCloudinary(file, {
    folder: "ph-healthcare/specialties",
    transformation: [
      { width: 200, height: 200, crop: "pad", background: "white" },
      { quality: 90 },
    ],
  });

  return result.secure_url;
};

// Upload medical documents (maintain quality)
const uploadMedicalDocument = async (
  file: Express.Multer.File
): Promise<string> => {
  const result = await uploadToCloudinary(file, {
    folder: "ph-healthcare/documents",
    transformation: [
      { quality: 95 }, // Higher quality for medical documents
    ],
  });

  return result.secure_url;
};

export const FileUploadHelper = {
  uploadToCloudinary,
  uploadProfilePhoto,
  uploadSpecialtyIcon,
  uploadMedicalDocument,
};
```

---

### Phase 4: Responsive Image Sizes

#### Step 4.1: Define Size Breakpoints

**File**: `frontend/src/lib/imageSizes.ts`

```typescript
/**
 * Responsive image sizes configuration
 * Based on Tailwind breakpoints
 */

export const IMAGE_SIZES = {
  // Doctor cards in grid
  doctorCard: {
    mobile: "100vw",
    tablet: "50vw",
    desktop: "33vw",
  },

  // Hero section
  hero: {
    mobile: "100vw",
    tablet: "100vw",
    desktop: "100vw",
  },

  // Specialty icons
  specialty: {
    mobile: "64px",
    tablet: "80px",
    desktop: "96px",
  },

  // Profile photo
  profile: {
    mobile: "100px",
    tablet: "150px",
    desktop: "200px",
  },

  // Avatar
  avatar: {
    mobile: "32px",
    tablet: "40px",
    desktop: "48px",
  },
} as const;

/**
 * Generate sizes string for Next.js Image component
 */
export function generateSizesString(config: {
  mobile: string;
  tablet: string;
  desktop: string;
}): string {
  return `(max-width: 640px) ${config.mobile}, (max-width: 1024px) ${config.tablet}, ${config.desktop}`;
}

// Pre-generated sizes strings
export const SIZES_DOCTOR_CARD = generateSizesString(IMAGE_SIZES.doctorCard);
export const SIZES_HERO = generateSizesString(IMAGE_SIZES.hero);
export const SIZES_PROFILE = generateSizesString(IMAGE_SIZES.profile);
```

**Usage**:

```tsx
import { SIZES_DOCTOR_CARD } from "@/lib/imageSizes";

<OptimizedImage
  src={doctor.profilePhoto}
  alt={doctor.name}
  width={400}
  height={400}
  sizes={SIZES_DOCTOR_CARD}
/>;
```

---

### Phase 5: Performance Monitoring

#### Step 5.1: Create Image Performance Tracker

**File**: `frontend/src/lib/imagePerformance.ts`

```typescript
/**
 * Track image loading performance
 */

interface ImagePerformanceMetric {
  url: string;
  loadTime: number;
  fileSize?: number;
  format?: string;
}

class ImagePerformanceTracker {
  private metrics: ImagePerformanceMetric[] = [];

  trackImageLoad(url: string, startTime: number) {
    const loadTime = performance.now() - startTime;

    this.metrics.push({
      url,
      loadTime,
    });

    // Log slow images
    if (loadTime > 1000) {
      console.warn(`Slow image load: ${url} (${loadTime}ms)`);
    }
  }

  getAverageLoadTime(): number {
    if (this.metrics.length === 0) return 0;

    const total = this.metrics.reduce((sum, m) => sum + m.loadTime, 0);
    return total / this.metrics.length;
  }

  getSlowImages(threshold: number = 1000): ImagePerformanceMetric[] {
    return this.metrics.filter((m) => m.loadTime > threshold);
  }

  report() {
    console.table({
      "Total Images": this.metrics.length,
      "Average Load Time": `${this.getAverageLoadTime().toFixed(2)}ms`,
      "Slow Images (>1s)": this.getSlowImages().length,
    });
  }

  reset() {
    this.metrics = [];
  }
}

export const imagePerformanceTracker = new ImagePerformanceTracker();

// Usage in component
export function useImagePerformance(src: string) {
  const startTime = performance.now();

  const onLoad = () => {
    imagePerformanceTracker.trackImageLoad(src, startTime);
  };

  return { onLoad };
}
```

**Usage in Component**:

```tsx
import { useImagePerformance } from "@/lib/imagePerformance";

function DoctorCard({ doctor }) {
  const { onLoad } = useImagePerformance(doctor.profilePhoto);

  return (
    <OptimizedImage
      src={doctor.profilePhoto}
      alt={doctor.name}
      width={300}
      height={300}
      onLoadingComplete={onLoad}
    />
  );
}
```

---

## ‚úÖ Testing Checklist

### Visual Testing

- [ ] All images load correctly
- [ ] No broken images (404s)
- [ ] Blur placeholders display during load
- [ ] No layout shift (CLS < 0.1)
- [ ] Correct aspect ratios maintained
- [ ] WebP/AVIF formats served to supported browsers

### Performance Testing

- [ ] LCP < 2.5s on all pages
- [ ] Total image weight reduced by >50%
- [ ] Hero image loads in <1s
- [ ] Doctor cards load progressively
- [ ] Lazy loading works below the fold
- [ ] Cache headers set correctly (1 year)

### Responsive Testing

- [ ] Images scale correctly on mobile
- [ ] Appropriate image sizes served per device
- [ ] srcset generates multiple sizes
- [ ] High DPI displays get 2x images

### Browser Testing

- [ ] Chrome: Serves AVIF
- [ ] Firefox: Serves WebP
- [ ] Safari: Serves WebP (iOS 14+)
- [ ] Edge: Serves AVIF
- [ ] Fallback to JPEG on old browsers

---

## üéØ Acceptance Criteria

1. ‚úÖ All `<img>` tags replaced with `<Image>` or `<OptimizedImage>`
2. ‚úÖ WebP/AVIF formats automatically served
3. ‚úÖ Blur placeholders on all images
4. ‚úÖ Lazy loading on below-the-fold images
5. ‚úÖ `priority` flag on hero/LCP images
6. ‚úÖ Responsive `sizes` attribute on all images
7. ‚úÖ Cloudinary transformations on upload
8. ‚úÖ 70%+ reduction in image weight
9. ‚úÖ LCP score < 2.5s
10. ‚úÖ CLS score < 0.1

---

## üìä Before & After Comparison

| Metric               | Before       | After        | Improvement |
| -------------------- | ------------ | ------------ | ----------- |
| Hero image size      | 1.5MB (JPEG) | 150KB (AVIF) | 90% ‚¨áÔ∏è      |
| Doctor profile photo | 500KB (PNG)  | 40KB (WebP)  | 92% ‚¨áÔ∏è      |
| Specialty icon       | 200KB (PNG)  | 15KB (WebP)  | 92% ‚¨áÔ∏è      |
| LCP                  | 4.2s         | 1.8s         | 57% ‚¨áÔ∏è      |
| CLS                  | 0.25         | 0.05         | 80% ‚¨áÔ∏è      |
| Total page weight    | 4.5MB        | 1.2MB        | 73% ‚¨áÔ∏è      |

---

## üìñ Resources

- [Next.js Image Optimization](https://nextjs.org/docs/app/building-your-application/optimizing/images)
- [Cloudinary Transformations](https://cloudinary.com/documentation/image_transformations)
- [WebP Image Format](https://developers.google.com/speed/webp)
- [AVIF Image Format](https://jakearchibald.com/2020/avif-has-landed/)
- [Core Web Vitals](https://web.dev/vitals/)

---

**Task Status**: üìù Ready for implementation  
**Estimated Completion**: 2-3 days  
**Quick Wins**: Start with hero image and doctor cards for immediate impact

---

_This optimization will drastically improve user experience, especially on mobile devices and slow connections. Expect 70-90% reduction in image sizes!_ üöÄ
